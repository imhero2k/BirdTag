{"ast":null,"code":"import kebabCase from 'lodash/kebabCase.js';\nimport '@aws-amplify/core/internals/utils';\nimport '../../utils/setUserAgent/constants.mjs';\nimport { has, isObject, isString } from '../../utils/utils.mjs';\nimport { usesReference } from '../../utils/references.mjs';\nconst CSS_VARIABLE_PREFIX = 'amplify';\n/**\n * This will take an object like:\n * {paddingTop:'20px',color:'{colors.font.primary}'}\n * and turn it into a CSS string:\n * `padding-top:20px; color: var(--colors-font-primary);`\n */\nfunction propsToString(props) {\n  return Object.entries(props).map(_ref => {\n    let [key, value] = _ref;\n    const _value = isDesignToken(value) ? value.toString() :\n    // @ts-ignore\n    cssValue({\n      value\n    });\n    return \"\".concat(kebabCase(key), \":\").concat(_value, \"; \");\n  }).join(' ');\n}\nfunction cssNameTransform(_ref2) {\n  let {\n    path = []\n  } = _ref2;\n  return \"\".concat(kebabCase([CSS_VARIABLE_PREFIX, ...path].join(' ')));\n}\n// Important: these properties should not be altered in\n// order to maintain the expected order of the CSS `box-shadow` property\nconst SHADOW_PROPERTIES = ['offsetX', 'offsetY', 'blurRadius', 'spreadRadius', 'color'];\n/**\n * Will take a design token in a theme and return its value as CSS\n *\n * @param token\n * @returns\n */\nfunction cssValue(token) {\n  const {\n    value\n  } = token;\n  if (isString(value)) {\n    return referenceValue(value);\n  }\n  if (isShadowTokenObject(value)) {\n    return SHADOW_PROPERTIES.map(property => {\n      return referenceValue(\n      // lookup property against `token` first for custom non-nested value, then lookup\n      // property against `value` for design token value\n      isShadowTokenObject(token) ? token[property] : value[property]);\n    }).join(' ');\n  }\n  return value;\n}\n/**\n * Helper function to test if something is a design token or not.\n * Used in the React component style props.\n *\n * @param value - thing to test if it is a design token or not\n * @returns boolean\n */\nfunction isDesignToken(value) {\n  return isObject(value) && has(value, 'value');\n}\nfunction isShadowTokenObject(value) {\n  return isObject(value) && has(value, 'offsetX');\n}\n/**\n * Function that sees if a string contains a design token reference\n * and if so will turn that into a CSS variable.\n *\n * @param {string} value\n * @returns string\n */\nfunction referenceValue(value) {\n  if (!value) return '';\n  if (usesReference(value)) {\n    const path = value.replace(/\\{|\\}/g, '').replace('.value', '').split('.');\n    return \"var(--\".concat(cssNameTransform({\n      path\n    }), \")\");\n  }\n  return value;\n}\n/**\n * This will take a design token and add some data to it for it\n * to be used in JS/CSS. It will create its CSS var name and update\n * the value to use a CSS var if it is a reference. It will also\n * add a `.toString()` method to make it easier to use in JS.\n *\n * We should see if there is a way to share this logic with style dictionary...\n */\nconst setupToken = _ref3 => {\n  let {\n    token,\n    path\n  } = _ref3;\n  const name = \"--\".concat(cssNameTransform({\n    path\n  }));\n  const {\n    value: original\n  } = token;\n  const value = cssValue(token);\n  return {\n    name,\n    original,\n    path,\n    value,\n    toString: () => \"var(\".concat(name, \")\")\n  };\n};\n/**\n * Recursive function that will walk down the token object\n * and perform the setupToken function on each token.\n * Similar to what Style Dictionary does.\n */\nfunction setupTokens(_ref4) {\n  let {\n    tokens,\n    path = [],\n    setupToken\n  } = _ref4;\n  if (has(tokens, 'value')) {\n    return setupToken({\n      token: tokens,\n      path\n    });\n  }\n  const output = {};\n  for (const name in tokens) {\n    if (has(tokens, name)) {\n      const value = tokens[name];\n      const nextTokens = isObject(value) ? value : {\n        value\n      };\n      output[name] = setupTokens({\n        tokens: nextTokens,\n        path: path.concat(name),\n        setupToken\n      });\n    }\n  }\n  return output;\n}\n// Internal Style Dictionary methods\n// copied from amzn/style-dictionary with the owner's permission\n/**\n * Takes an plain javascript object and will make a flat array of all the leaf nodes.\n * A leaf node in this context has a 'value' property. Potentially refactor this to\n * be more generic.\n * @private\n * @param  {Object} properties - The plain object you want flattened into an array.\n * @param  {Array} [to_ret=[]] - Properties array. This function is recursive therefore this is what gets passed along.\n * @return {Array}\n */\nfunction flattenProperties(properties, to_ret) {\n  to_ret = to_ret || [];\n  for (var name in properties) {\n    if (has(properties, name)) {\n      if (isObject(properties[name]) && 'value' in properties[name]) {\n        to_ret.push(properties[name]);\n      } else if (isObject(properties[name])) {\n        flattenProperties(properties[name], to_ret);\n      }\n    }\n  }\n  return to_ret;\n}\n/**\n * Performs an deep extend on the objects, from right to left.\n * @private\n * @param {Object[]} objects - An array of JS objects\n * @param {Function} collision - A function to be called when a merge collision happens.\n * @param {string[]} path - (for internal use) An array of strings which is the current path down the object when this is called recursively.\n * @returns {Object}\n */\nfunction deepExtend(objects, collision, path) {\n  if (objects == null) return {};\n  var src,\n    copyIsArray,\n    copy,\n    name,\n    options,\n    clone,\n    target = objects[0] || {},\n    i = 1,\n    length = objects.length;\n  path = path || [];\n  // Handle case when target is a string or something (possible in deep copy)\n  if (typeof target !== 'object') {\n    target = {};\n  }\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = objects[i]) != null) {\n      // Extend the base object\n      for (name in options) {\n        if (!has(options, name)) continue;\n        if (name === '__proto__') continue;\n        src = target[name];\n        copy = options[name];\n        // Prevent never-ending loop\n        if (target === copy) {\n          continue;\n        }\n        // Recurse if we're merging plain objects or arrays\n        if (copy && (isObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n          if (copyIsArray) {\n            copyIsArray = false;\n            clone = src && Array.isArray(src) ? src : [];\n          } else {\n            clone = src && isObject(src) ? src : {};\n          }\n          var nextPath = path.slice(0);\n          nextPath.push(name);\n          // Never move original objects, clone them\n          target[name] = deepExtend([clone, copy], collision, nextPath);\n          // Don't bring in undefined values\n        } else if (copy !== undefined) {\n          if (src != null && typeof collision == 'function') {\n            collision({\n              target: target,\n              copy: options,\n              path: path,\n              key: name\n            });\n          }\n          target[name] = copy;\n        }\n      }\n    }\n  }\n  return target;\n}\nexport { CSS_VARIABLE_PREFIX, cssNameTransform, cssValue, deepExtend, flattenProperties, isDesignToken, isShadowTokenObject, propsToString, referenceValue, setupToken, setupTokens };","map":{"version":3,"names":["kebabCase","has","isObject","isString","usesReference","CSS_VARIABLE_PREFIX","propsToString","props","Object","entries","map","_ref","key","value","_value","isDesignToken","toString","cssValue","concat","join","cssNameTransform","_ref2","path","SHADOW_PROPERTIES","token","referenceValue","isShadowTokenObject","property","replace","split","setupToken","_ref3","name","original","setupTokens","_ref4","tokens","output","nextTokens","flattenProperties","properties","to_ret","push","deepExtend","objects","collision","src","copyIsArray","copy","options","clone","target","i","length","Array","isArray","nextPath","slice","undefined"],"sources":["/Users/saisaran/Desktop/BirdTag/UI/node_modules/@aws-amplify/ui/dist/esm/theme/createTheme/utils.mjs"],"sourcesContent":["import kebabCase from 'lodash/kebabCase.js';\nimport '@aws-amplify/core/internals/utils';\nimport '../../utils/setUserAgent/constants.mjs';\nimport { has, isObject, isString } from '../../utils/utils.mjs';\nimport { usesReference } from '../../utils/references.mjs';\n\nconst CSS_VARIABLE_PREFIX = 'amplify';\n/**\n * This will take an object like:\n * {paddingTop:'20px',color:'{colors.font.primary}'}\n * and turn it into a CSS string:\n * `padding-top:20px; color: var(--colors-font-primary);`\n */\nfunction propsToString(props) {\n    return Object.entries(props)\n        .map(([key, value]) => {\n        const _value = isDesignToken(value)\n            ? value.toString()\n            : // @ts-ignore\n                cssValue({ value });\n        return `${kebabCase(key)}:${_value}; `;\n    })\n        .join(' ');\n}\nfunction cssNameTransform({ path = [] }) {\n    return `${kebabCase([CSS_VARIABLE_PREFIX, ...path].join(' '))}`;\n}\n// Important: these properties should not be altered in\n// order to maintain the expected order of the CSS `box-shadow` property\nconst SHADOW_PROPERTIES = [\n    'offsetX',\n    'offsetY',\n    'blurRadius',\n    'spreadRadius',\n    'color',\n];\n/**\n * Will take a design token in a theme and return its value as CSS\n *\n * @param token\n * @returns\n */\nfunction cssValue(token) {\n    const { value } = token;\n    if (isString(value)) {\n        return referenceValue(value);\n    }\n    if (isShadowTokenObject(value)) {\n        return SHADOW_PROPERTIES.map((property) => {\n            return referenceValue(\n            // lookup property against `token` first for custom non-nested value, then lookup\n            // property against `value` for design token value\n            isShadowTokenObject(token) ? token[property] : value[property]);\n        }).join(' ');\n    }\n    return value;\n}\n/**\n * Helper function to test if something is a design token or not.\n * Used in the React component style props.\n *\n * @param value - thing to test if it is a design token or not\n * @returns boolean\n */\nfunction isDesignToken(value) {\n    return isObject(value) && has(value, 'value');\n}\nfunction isShadowTokenObject(value) {\n    return isObject(value) && has(value, 'offsetX');\n}\n/**\n * Function that sees if a string contains a design token reference\n * and if so will turn that into a CSS variable.\n *\n * @param {string} value\n * @returns string\n */\nfunction referenceValue(value) {\n    if (!value)\n        return '';\n    if (usesReference(value)) {\n        const path = value.replace(/\\{|\\}/g, '').replace('.value', '').split('.');\n        return `var(--${cssNameTransform({ path })})`;\n    }\n    return value;\n}\n/**\n * This will take a design token and add some data to it for it\n * to be used in JS/CSS. It will create its CSS var name and update\n * the value to use a CSS var if it is a reference. It will also\n * add a `.toString()` method to make it easier to use in JS.\n *\n * We should see if there is a way to share this logic with style dictionary...\n */\nconst setupToken = ({ token, path }) => {\n    const name = `--${cssNameTransform({ path })}`;\n    const { value: original } = token;\n    const value = cssValue(token);\n    return { name, original, path, value, toString: () => `var(${name})` };\n};\n/**\n * Recursive function that will walk down the token object\n * and perform the setupToken function on each token.\n * Similar to what Style Dictionary does.\n */\nfunction setupTokens({ tokens, path = [], setupToken, }) {\n    if (has(tokens, 'value')) {\n        return setupToken({ token: tokens, path });\n    }\n    const output = {};\n    for (const name in tokens) {\n        if (has(tokens, name)) {\n            const value = tokens[name];\n            const nextTokens = isObject(value) ? value : { value };\n            output[name] = setupTokens({\n                tokens: nextTokens,\n                path: path.concat(name),\n                setupToken,\n            });\n        }\n    }\n    return output;\n}\n// Internal Style Dictionary methods\n// copied from amzn/style-dictionary with the owner's permission\n/**\n * Takes an plain javascript object and will make a flat array of all the leaf nodes.\n * A leaf node in this context has a 'value' property. Potentially refactor this to\n * be more generic.\n * @private\n * @param  {Object} properties - The plain object you want flattened into an array.\n * @param  {Array} [to_ret=[]] - Properties array. This function is recursive therefore this is what gets passed along.\n * @return {Array}\n */\nfunction flattenProperties(properties, to_ret) {\n    to_ret = to_ret || [];\n    for (var name in properties) {\n        if (has(properties, name)) {\n            if (isObject(properties[name]) && 'value' in properties[name]) {\n                to_ret.push(properties[name]);\n            }\n            else if (isObject(properties[name])) {\n                flattenProperties(properties[name], to_ret);\n            }\n        }\n    }\n    return to_ret;\n}\n/**\n * Performs an deep extend on the objects, from right to left.\n * @private\n * @param {Object[]} objects - An array of JS objects\n * @param {Function} collision - A function to be called when a merge collision happens.\n * @param {string[]} path - (for internal use) An array of strings which is the current path down the object when this is called recursively.\n * @returns {Object}\n */\nfunction deepExtend(objects, collision, path) {\n    if (objects == null)\n        return {};\n    var src, copyIsArray, copy, name, options, clone, target = objects[0] || {}, i = 1, length = objects.length;\n    path = path || [];\n    // Handle case when target is a string or something (possible in deep copy)\n    if (typeof target !== 'object') {\n        target = {};\n    }\n    for (; i < length; i++) {\n        // Only deal with non-null/undefined values\n        if ((options = objects[i]) != null) {\n            // Extend the base object\n            for (name in options) {\n                if (!has(options, name))\n                    continue;\n                if (name === '__proto__')\n                    continue;\n                src = target[name];\n                copy = options[name];\n                // Prevent never-ending loop\n                if (target === copy) {\n                    continue;\n                }\n                // Recurse if we're merging plain objects or arrays\n                if (copy && (isObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n                    if (copyIsArray) {\n                        copyIsArray = false;\n                        clone = src && Array.isArray(src) ? src : [];\n                    }\n                    else {\n                        clone = src && isObject(src) ? src : {};\n                    }\n                    var nextPath = path.slice(0);\n                    nextPath.push(name);\n                    // Never move original objects, clone them\n                    target[name] = deepExtend([clone, copy], collision, nextPath);\n                    // Don't bring in undefined values\n                }\n                else if (copy !== undefined) {\n                    if (src != null && typeof collision == 'function') {\n                        collision({ target: target, copy: options, path: path, key: name });\n                    }\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n    return target;\n}\n\nexport { CSS_VARIABLE_PREFIX, cssNameTransform, cssValue, deepExtend, flattenProperties, isDesignToken, isShadowTokenObject, propsToString, referenceValue, setupToken, setupTokens };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}