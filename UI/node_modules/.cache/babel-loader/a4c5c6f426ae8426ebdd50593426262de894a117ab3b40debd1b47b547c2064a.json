{"ast":null,"code":"import _objectSpread from \"/Users/saisaran/Desktop/BirdTag/UI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { assertValidationError } from '../../../errors/utils/assertValidationError.mjs';\nimport { StorageValidationErrorCode } from '../../../errors/types/validation.mjs';\nimport { resolvePrefix } from '../../../utils/resolvePrefix.mjs';\nimport { StorageError } from '../../../errors/StorageError.mjs';\nimport { INVALID_STORAGE_INPUT } from '../../../errors/constants.mjs';\nimport { DEFAULT_ACCESS_LEVEL, LOCAL_TESTING_S3_ENDPOINT } from './constants.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * resolve the common input options for S3 API handlers from Amplify configuration and library options.\n *\n * @param {AmplifyClassV6} amplify The Amplify instance.\n * @param {S3ApiOptions} apiOptions The input options for S3 provider.\n * @returns {Promise<ResolvedS3ConfigAndInput>} The resolved common input options for S3 API handlers.\n * @throws A `StorageError` with `error.name` from `StorageValidationErrorCode` indicating invalid\n *   configurations or Amplify library options.\n *\n * @internal\n */\nconst resolveS3ConfigAndInput = async (amplify, apiInput) => {\n  var _amplify$getConfig$St, _amplify$getConfig, _amplify$libraryOptio, _amplify$libraryOptio2, _ref, _apiOptions$accessLev, _apiOptions$targetIde;\n  const {\n    options: apiOptions\n  } = apiInput !== null && apiInput !== void 0 ? apiInput : {};\n  /**\n   * IdentityId is always cached in memory so we can safely make calls here. It\n   * should be stable even for unauthenticated users, regardless of credentials.\n   */\n  const {\n    identityId\n  } = await amplify.Auth.fetchAuthSession();\n  /**\n   * A credentials provider function instead of a static credentials object is\n   * used because the long-running tasks like multipart upload may span over the\n   * credentials expiry. Auth.fetchAuthSession() automatically refreshes the\n   * credentials if they are expired.\n   *\n   * The optional forceRefresh option is set when the S3 service returns expired\n   * tokens error in the previous API call attempt.\n   */\n  const credentialsProvider = async options => {\n    if (isLocationCredentialsProvider(apiOptions)) {\n      assertStorageInput(apiInput);\n    }\n    // TODO: forceRefresh option of fetchAuthSession would refresh both tokens and\n    // AWS credentials. So we do not support forceRefreshing from the Auth until\n    // we support refreshing only the credentials.\n    const {\n      credentials\n    } = isLocationCredentialsProvider(apiOptions) ? await apiOptions.locationCredentialsProvider(options) : await amplify.Auth.fetchAuthSession();\n    assertValidationError(!!credentials, StorageValidationErrorCode.NoCredentials);\n    return credentials;\n  };\n  const {\n    bucket: defaultBucket,\n    region: defaultRegion,\n    dangerouslyConnectToHttpEndpointForTesting,\n    buckets\n  } = (_amplify$getConfig$St = (_amplify$getConfig = amplify.getConfig()) === null || _amplify$getConfig === void 0 || (_amplify$getConfig = _amplify$getConfig.Storage) === null || _amplify$getConfig === void 0 ? void 0 : _amplify$getConfig.S3) !== null && _amplify$getConfig$St !== void 0 ? _amplify$getConfig$St : {};\n  const {\n    bucket = defaultBucket,\n    region = defaultRegion\n  } = (apiOptions === null || apiOptions === void 0 ? void 0 : apiOptions.bucket) && resolveBucketConfig(apiOptions, buckets) || {};\n  assertValidationError(!!bucket, StorageValidationErrorCode.NoBucket);\n  assertValidationError(!!region, StorageValidationErrorCode.NoRegion);\n  const {\n    defaultAccessLevel,\n    prefixResolver = resolvePrefix,\n    isObjectLockEnabled\n  } = (_amplify$libraryOptio = (_amplify$libraryOptio2 = amplify.libraryOptions) === null || _amplify$libraryOptio2 === void 0 || (_amplify$libraryOptio2 = _amplify$libraryOptio2.Storage) === null || _amplify$libraryOptio2 === void 0 ? void 0 : _amplify$libraryOptio2.S3) !== null && _amplify$libraryOptio !== void 0 ? _amplify$libraryOptio : {};\n  const accessLevel = (_ref = (_apiOptions$accessLev = apiOptions === null || apiOptions === void 0 ? void 0 : apiOptions.accessLevel) !== null && _apiOptions$accessLev !== void 0 ? _apiOptions$accessLev : defaultAccessLevel) !== null && _ref !== void 0 ? _ref : DEFAULT_ACCESS_LEVEL;\n  const targetIdentityId = accessLevel === 'protected' ? (_apiOptions$targetIde = apiOptions === null || apiOptions === void 0 ? void 0 : apiOptions.targetIdentityId) !== null && _apiOptions$targetIde !== void 0 ? _apiOptions$targetIde : identityId : identityId;\n  const keyPrefix = await prefixResolver({\n    accessLevel,\n    targetIdentityId\n  });\n  return {\n    s3Config: _objectSpread(_objectSpread({\n      credentials: credentialsProvider,\n      region,\n      useAccelerateEndpoint: apiOptions === null || apiOptions === void 0 ? void 0 : apiOptions.useAccelerateEndpoint\n    }, apiOptions !== null && apiOptions !== void 0 && apiOptions.customEndpoint ? {\n      customEndpoint: apiOptions.customEndpoint\n    } : {}), dangerouslyConnectToHttpEndpointForTesting ? {\n      customEndpoint: LOCAL_TESTING_S3_ENDPOINT,\n      forcePathStyle: true\n    } : {}),\n    bucket,\n    keyPrefix,\n    identityId,\n    isObjectLockEnabled\n  };\n};\nconst isLocationCredentialsProvider = options => {\n  return !!(options !== null && options !== void 0 && options.locationCredentialsProvider);\n};\nconst isInputWithCallbackPath = input => {\n  var _input$destination, _input$destination2, _input$source, _input$source2;\n  return (input === null || input === void 0 ? void 0 : input.path) && typeof input.path === 'function' || (input === null || input === void 0 || (_input$destination = input.destination) === null || _input$destination === void 0 ? void 0 : _input$destination.path) && typeof ((_input$destination2 = input.destination) === null || _input$destination2 === void 0 ? void 0 : _input$destination2.path) === 'function' || (input === null || input === void 0 || (_input$source = input.source) === null || _input$source === void 0 ? void 0 : _input$source.path) && typeof ((_input$source2 = input.source) === null || _input$source2 === void 0 ? void 0 : _input$source2.path) === 'function';\n};\nconst isDeprecatedInput = input => {\n  return isInputWithKey(input) || isInputWithPrefix(input) || isInputWithCopySourceOrDestination(input);\n};\nconst assertStorageInput = input => {\n  if (isDeprecatedInput(input) || isInputWithCallbackPath(input)) {\n    throw new StorageError({\n      name: INVALID_STORAGE_INPUT,\n      message: 'The input needs to have a path as a string value.',\n      recoverySuggestion: 'Please provide a valid path as a string value for the input.'\n    });\n  }\n};\nconst isInputWithKey = input => {\n  return !!(typeof input.key === 'string');\n};\nconst isInputWithPrefix = input => {\n  return !!(typeof input.prefix === 'string');\n};\nconst isInputWithCopySourceOrDestination = input => {\n  var _input$source3, _input$destination3;\n  return !!(typeof ((_input$source3 = input.source) === null || _input$source3 === void 0 ? void 0 : _input$source3.key) === 'string' || typeof ((_input$destination3 = input.destination) === null || _input$destination3 === void 0 ? void 0 : _input$destination3.key) === 'string');\n};\nconst resolveBucketConfig = (apiOptions, buckets) => {\n  if (typeof apiOptions.bucket === 'string') {\n    const bucketConfig = buckets === null || buckets === void 0 ? void 0 : buckets[apiOptions.bucket];\n    assertValidationError(!!bucketConfig, StorageValidationErrorCode.InvalidStorageBucket);\n    return {\n      bucket: bucketConfig.bucketName,\n      region: bucketConfig.region\n    };\n  }\n  if (typeof apiOptions.bucket === 'object') {\n    return {\n      bucket: apiOptions.bucket.bucketName,\n      region: apiOptions.bucket.region\n    };\n  }\n};\nexport { resolveS3ConfigAndInput };","map":{"version":3,"names":["resolveS3ConfigAndInput","amplify","apiInput","_amplify$getConfig$St","_amplify$getConfig","_amplify$libraryOptio","_amplify$libraryOptio2","_ref","_apiOptions$accessLev","_apiOptions$targetIde","options","apiOptions","identityId","Auth","fetchAuthSession","credentialsProvider","isLocationCredentialsProvider","assertStorageInput","credentials","locationCredentialsProvider","assertValidationError","StorageValidationErrorCode","NoCredentials","bucket","defaultBucket","region","defaultRegion","dangerouslyConnectToHttpEndpointForTesting","buckets","getConfig","Storage","S3","resolveBucketConfig","NoBucket","NoRegion","defaultAccessLevel","prefixResolver","resolvePrefix","isObjectLockEnabled","libraryOptions","accessLevel","DEFAULT_ACCESS_LEVEL","targetIdentityId","keyPrefix","s3Config","_objectSpread","useAccelerateEndpoint","customEndpoint","LOCAL_TESTING_S3_ENDPOINT","forcePathStyle","isInputWithCallbackPath","input","_input$destination","_input$destination2","_input$source","_input$source2","path","destination","source","isDeprecatedInput","isInputWithKey","isInputWithPrefix","isInputWithCopySourceOrDestination","StorageError","name","INVALID_STORAGE_INPUT","message","recoverySuggestion","key","prefix","_input$source3","_input$destination3","bucketConfig","InvalidStorageBucket","bucketName"],"sources":["/Users/saisaran/Desktop/BirdTag/UI/node_modules/@aws-amplify/storage/src/providers/s3/utils/resolveS3ConfigAndInput.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { assertValidationError } from '../../../errors/utils/assertValidationError';\nimport { StorageValidationErrorCode } from '../../../errors/types/validation';\nimport { resolvePrefix as defaultPrefixResolver } from '../../../utils/resolvePrefix';\nimport { StorageError } from '../../../errors/StorageError';\nimport { INVALID_STORAGE_INPUT } from '../../../errors/constants';\nimport { DEFAULT_ACCESS_LEVEL, LOCAL_TESTING_S3_ENDPOINT } from './constants';\n/**\n * resolve the common input options for S3 API handlers from Amplify configuration and library options.\n *\n * @param {AmplifyClassV6} amplify The Amplify instance.\n * @param {S3ApiOptions} apiOptions The input options for S3 provider.\n * @returns {Promise<ResolvedS3ConfigAndInput>} The resolved common input options for S3 API handlers.\n * @throws A `StorageError` with `error.name` from `StorageValidationErrorCode` indicating invalid\n *   configurations or Amplify library options.\n *\n * @internal\n */\nexport const resolveS3ConfigAndInput = async (amplify, apiInput) => {\n    const { options: apiOptions } = apiInput ?? {};\n    /**\n     * IdentityId is always cached in memory so we can safely make calls here. It\n     * should be stable even for unauthenticated users, regardless of credentials.\n     */\n    const { identityId } = await amplify.Auth.fetchAuthSession();\n    /**\n     * A credentials provider function instead of a static credentials object is\n     * used because the long-running tasks like multipart upload may span over the\n     * credentials expiry. Auth.fetchAuthSession() automatically refreshes the\n     * credentials if they are expired.\n     *\n     * The optional forceRefresh option is set when the S3 service returns expired\n     * tokens error in the previous API call attempt.\n     */\n    const credentialsProvider = async (options) => {\n        if (isLocationCredentialsProvider(apiOptions)) {\n            assertStorageInput(apiInput);\n        }\n        // TODO: forceRefresh option of fetchAuthSession would refresh both tokens and\n        // AWS credentials. So we do not support forceRefreshing from the Auth until\n        // we support refreshing only the credentials.\n        const { credentials } = isLocationCredentialsProvider(apiOptions)\n            ? await apiOptions.locationCredentialsProvider(options)\n            : await amplify.Auth.fetchAuthSession();\n        assertValidationError(!!credentials, StorageValidationErrorCode.NoCredentials);\n        return credentials;\n    };\n    const { bucket: defaultBucket, region: defaultRegion, dangerouslyConnectToHttpEndpointForTesting, buckets, } = amplify.getConfig()?.Storage?.S3 ?? {};\n    const { bucket = defaultBucket, region = defaultRegion } = (apiOptions?.bucket && resolveBucketConfig(apiOptions, buckets)) || {};\n    assertValidationError(!!bucket, StorageValidationErrorCode.NoBucket);\n    assertValidationError(!!region, StorageValidationErrorCode.NoRegion);\n    const { defaultAccessLevel, prefixResolver = defaultPrefixResolver, isObjectLockEnabled, } = amplify.libraryOptions?.Storage?.S3 ?? {};\n    const accessLevel = apiOptions?.accessLevel ?? defaultAccessLevel ?? DEFAULT_ACCESS_LEVEL;\n    const targetIdentityId = accessLevel === 'protected'\n        ? (apiOptions?.targetIdentityId ?? identityId)\n        : identityId;\n    const keyPrefix = await prefixResolver({ accessLevel, targetIdentityId });\n    return {\n        s3Config: {\n            credentials: credentialsProvider,\n            region,\n            useAccelerateEndpoint: apiOptions?.useAccelerateEndpoint,\n            ...(apiOptions?.customEndpoint\n                ? { customEndpoint: apiOptions.customEndpoint }\n                : {}),\n            ...(dangerouslyConnectToHttpEndpointForTesting\n                ? {\n                    customEndpoint: LOCAL_TESTING_S3_ENDPOINT,\n                    forcePathStyle: true,\n                }\n                : {}),\n        },\n        bucket,\n        keyPrefix,\n        identityId,\n        isObjectLockEnabled,\n    };\n};\nconst isLocationCredentialsProvider = (options) => {\n    return !!options?.locationCredentialsProvider;\n};\nconst isInputWithCallbackPath = (input) => {\n    return ((input?.path &&\n        typeof input.path === 'function') ||\n        (input?.destination?.path &&\n            typeof input.destination?.path === 'function') ||\n        (input?.source?.path &&\n            typeof input.source?.path === 'function'));\n};\nconst isDeprecatedInput = (input) => {\n    return (isInputWithKey(input) ||\n        isInputWithPrefix(input) ||\n        isInputWithCopySourceOrDestination(input));\n};\nconst assertStorageInput = (input) => {\n    if (isDeprecatedInput(input) || isInputWithCallbackPath(input)) {\n        throw new StorageError({\n            name: INVALID_STORAGE_INPUT,\n            message: 'The input needs to have a path as a string value.',\n            recoverySuggestion: 'Please provide a valid path as a string value for the input.',\n        });\n    }\n};\nconst isInputWithKey = (input) => {\n    return !!(typeof input.key === 'string');\n};\nconst isInputWithPrefix = (input) => {\n    return !!(typeof input.prefix === 'string');\n};\nconst isInputWithCopySourceOrDestination = (input) => {\n    return !!(typeof input.source?.key === 'string' ||\n        typeof input.destination?.key === 'string');\n};\nconst resolveBucketConfig = (apiOptions, buckets) => {\n    if (typeof apiOptions.bucket === 'string') {\n        const bucketConfig = buckets?.[apiOptions.bucket];\n        assertValidationError(!!bucketConfig, StorageValidationErrorCode.InvalidStorageBucket);\n        return { bucket: bucketConfig.bucketName, region: bucketConfig.region };\n    }\n    if (typeof apiOptions.bucket === 'object') {\n        return {\n            bucket: apiOptions.bucket.bucketName,\n            region: apiOptions.bucket.region,\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}