{"ast":null,"code":"import _objectSpread from \"/Users/saisaran/Desktop/BirdTag/UI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { ConsoleLogger } from '../../../Logger/ConsoleLogger.mjs';\nimport '../../../types/errors.mjs';\nimport '../../../errors/errorHelpers.mjs';\nimport '../../../utils/getClientInfo/getClientInfo.mjs';\nimport '../../../utils/retry/retry.mjs';\nimport '../../../parseAWSExports.mjs';\nimport 'uuid';\nimport '../../../singleton/Auth/utils/errorHelpers.mjs';\nimport '@aws-crypto/sha256-js';\nimport '@smithy/util-hex-encoding';\nimport '../../../Platform/index.mjs';\nimport '../../../Platform/types.mjs';\nimport '../../../BackgroundProcessManager/types.mjs';\nimport '../../../Reachability/Reachability.mjs';\nimport '../../../Hub/index.mjs';\nimport '../../../utils/sessionListener/index.mjs';\nimport '../../../awsClients/pinpoint/base.mjs';\nimport { putEvents } from '../../../awsClients/pinpoint/putEvents.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('PinpointEventBuffer');\nconst RETRYABLE_CODES = [429, 500];\nconst ACCEPTED_CODES = [202];\nclass PinpointEventBuffer {\n  constructor(config) {\n    this._interval = undefined;\n    this._pause = false;\n    this._flush = false;\n    this._buffer = [];\n    this._config = config;\n    this._sendBatch = this._sendBatch.bind(this);\n    this._startLoop();\n  }\n  push(event) {\n    if (this._buffer.length >= this._config.bufferSize) {\n      logger.debug('Exceeded Pinpoint event buffer limits, event dropped.', {\n        eventId: event.eventId\n      });\n      return;\n    }\n    this._buffer.push({\n      [event.eventId]: event\n    });\n  }\n  pause() {\n    this._pause = true;\n  }\n  resume() {\n    this._pause = false;\n  }\n  flush() {\n    this._flush = true;\n  }\n  identityHasChanged(identityId) {\n    return this._config.identityId !== identityId;\n  }\n  flushAll() {\n    this._putEvents(this._buffer.splice(0, this._buffer.length));\n  }\n  _startLoop() {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n    const {\n      flushInterval\n    } = this._config;\n    this._interval = setInterval(this._sendBatch, flushInterval);\n  }\n  _sendBatch() {\n    const bufferLength = this._buffer.length;\n    if (this._flush && !bufferLength && this._interval) {\n      clearInterval(this._interval);\n    }\n    if (this._pause || !bufferLength || false) {\n      return;\n    }\n    const {\n      flushSize\n    } = this._config;\n    const batchSize = Math.min(flushSize, bufferLength);\n    const bufferSubset = this._buffer.splice(0, batchSize);\n    this._putEvents(bufferSubset);\n  }\n  async _putEvents(buffer) {\n    const eventMap = this._bufferToMap(buffer);\n    const batchEventParams = this._generateBatchEventParams(eventMap);\n    try {\n      const {\n        credentials,\n        region,\n        userAgentValue\n      } = this._config;\n      const data = await putEvents({\n        credentials,\n        region,\n        userAgentValue\n      }, batchEventParams);\n      this._processPutEventsSuccessResponse(data, eventMap);\n    } catch (err) {\n      this._handlePutEventsFailure(err, eventMap);\n    }\n  }\n  _generateBatchEventParams(eventMap) {\n    const batchItem = {};\n    Object.values(eventMap).forEach(item => {\n      var _batchItem$endpointId, _batchItem$endpointId2;\n      const {\n        event,\n        timestamp,\n        endpointId,\n        eventId,\n        session\n      } = item;\n      const {\n        name,\n        attributes,\n        metrics\n      } = event;\n      batchItem[endpointId] = {\n        Endpoint: _objectSpread({}, (_batchItem$endpointId = batchItem[endpointId]) === null || _batchItem$endpointId === void 0 ? void 0 : _batchItem$endpointId.Endpoint),\n        Events: _objectSpread(_objectSpread({}, (_batchItem$endpointId2 = batchItem[endpointId]) === null || _batchItem$endpointId2 === void 0 ? void 0 : _batchItem$endpointId2.Events), {}, {\n          [eventId]: {\n            EventType: name,\n            Timestamp: new Date(timestamp).toISOString(),\n            Attributes: attributes,\n            Metrics: metrics,\n            Session: session\n          }\n        })\n      };\n    });\n    return {\n      ApplicationId: this._config.appId,\n      EventsRequest: {\n        BatchItem: batchItem\n      }\n    };\n  }\n  _handlePutEventsFailure(err, eventMap) {\n    logger.debug('putEvents call to Pinpoint failed.', err);\n    const statusCode = err.$metadata && err.$metadata.httpStatusCode;\n    if (RETRYABLE_CODES.includes(statusCode)) {\n      const retryableEvents = Object.values(eventMap);\n      this._retry(retryableEvents);\n    }\n  }\n  _processPutEventsSuccessResponse(data, eventMap) {\n    var _data$EventsResponse;\n    const {\n      Results = {}\n    } = (_data$EventsResponse = data.EventsResponse) !== null && _data$EventsResponse !== void 0 ? _data$EventsResponse : {};\n    const retryableEvents = [];\n    Object.entries(Results).forEach(_ref => {\n      var _endpointValues$Event;\n      let [_, endpointValues] = _ref;\n      const responses = (_endpointValues$Event = endpointValues.EventsItemResponse) !== null && _endpointValues$Event !== void 0 ? _endpointValues$Event : {};\n      Object.entries(responses).forEach(_ref2 => {\n        let [eventId, eventValues] = _ref2;\n        const eventObject = eventMap[eventId];\n        if (!eventObject) {\n          return;\n        }\n        const {\n          StatusCode,\n          Message\n        } = eventValues !== null && eventValues !== void 0 ? eventValues : {};\n        if (StatusCode && ACCEPTED_CODES.includes(StatusCode)) {\n          return;\n        }\n        if (StatusCode && RETRYABLE_CODES.includes(StatusCode)) {\n          retryableEvents.push(eventObject);\n          return;\n        }\n        const {\n          name\n        } = eventObject.event;\n        logger.warn('Pinpoint event failed to send.', {\n          eventId,\n          name,\n          message: Message\n        });\n      });\n    });\n    if (retryableEvents.length) {\n      this._retry(retryableEvents);\n    }\n  }\n  _retry(retryableEvents) {\n    // retryable events that haven't reached the resendLimit\n    const eligibleEvents = [];\n    retryableEvents.forEach(bufferedEvent => {\n      const {\n        eventId\n      } = bufferedEvent;\n      const {\n        name\n      } = bufferedEvent.event;\n      if (bufferedEvent.resendLimit-- > 0) {\n        logger.debug('Resending event.', {\n          eventId,\n          name,\n          remainingAttempts: bufferedEvent.resendLimit\n        });\n        eligibleEvents.push({\n          [eventId]: bufferedEvent\n        });\n        return;\n      }\n      logger.debug('No retry attempts remaining for event.', {\n        eventId,\n        name\n      });\n    });\n    // add the events to the front of the buffer\n    this._buffer.unshift(...eligibleEvents);\n  }\n  _bufferToMap(buffer) {\n    return buffer.reduce((acc, curVal) => {\n      const [[key, value]] = Object.entries(curVal);\n      acc[key] = value;\n      return acc;\n    }, {});\n  }\n}\nexport { PinpointEventBuffer };","map":{"version":3,"names":["logger","ConsoleLogger","RETRYABLE_CODES","ACCEPTED_CODES","PinpointEventBuffer","constructor","config","_interval","undefined","_pause","_flush","_buffer","_config","_sendBatch","bind","_startLoop","push","event","length","bufferSize","debug","eventId","pause","resume","flush","identityHasChanged","identityId","flushAll","_putEvents","splice","clearInterval","flushInterval","setInterval","bufferLength","flushSize","batchSize","Math","min","bufferSubset","buffer","eventMap","_bufferToMap","batchEventParams","_generateBatchEventParams","credentials","region","userAgentValue","data","putEvents","_processPutEventsSuccessResponse","err","_handlePutEventsFailure","batchItem","Object","values","forEach","item","_batchItem$endpointId","_batchItem$endpointId2","timestamp","endpointId","session","name","attributes","metrics","Endpoint","_objectSpread","Events","EventType","Timestamp","Date","toISOString","Attributes","Metrics","Session","ApplicationId","appId","EventsRequest","BatchItem","statusCode","$metadata","httpStatusCode","includes","retryableEvents","_retry","_data$EventsResponse","Results","EventsResponse","entries","_ref","_endpointValues$Event","_","endpointValues","responses","EventsItemResponse","_ref2","eventValues","eventObject","StatusCode","Message","warn","message","eligibleEvents","bufferedEvent","resendLimit","remainingAttempts","unshift","reduce","acc","curVal","key","value"],"sources":["/Users/saisaran/Desktop/BirdTag/UI/node_modules/@aws-amplify/core/src/providers/pinpoint/utils/PinpointEventBuffer.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ConsoleLogger } from '../../../Logger';\nimport { putEvents, } from '../../../awsClients/pinpoint';\nimport { isAppInForeground } from './isAppInForeground';\nconst logger = new ConsoleLogger('PinpointEventBuffer');\nconst RETRYABLE_CODES = [429, 500];\nconst ACCEPTED_CODES = [202];\nexport class PinpointEventBuffer {\n    constructor(config) {\n        this._interval = undefined;\n        this._pause = false;\n        this._flush = false;\n        this._buffer = [];\n        this._config = config;\n        this._sendBatch = this._sendBatch.bind(this);\n        this._startLoop();\n    }\n    push(event) {\n        if (this._buffer.length >= this._config.bufferSize) {\n            logger.debug('Exceeded Pinpoint event buffer limits, event dropped.', {\n                eventId: event.eventId,\n            });\n            return;\n        }\n        this._buffer.push({ [event.eventId]: event });\n    }\n    pause() {\n        this._pause = true;\n    }\n    resume() {\n        this._pause = false;\n    }\n    flush() {\n        this._flush = true;\n    }\n    identityHasChanged(identityId) {\n        return this._config.identityId !== identityId;\n    }\n    flushAll() {\n        this._putEvents(this._buffer.splice(0, this._buffer.length));\n    }\n    _startLoop() {\n        if (this._interval) {\n            clearInterval(this._interval);\n        }\n        const { flushInterval } = this._config;\n        this._interval = setInterval(this._sendBatch, flushInterval);\n    }\n    _sendBatch() {\n        const bufferLength = this._buffer.length;\n        if (this._flush && !bufferLength && this._interval) {\n            clearInterval(this._interval);\n        }\n        if (this._pause || !bufferLength || !isAppInForeground()) {\n            return;\n        }\n        const { flushSize } = this._config;\n        const batchSize = Math.min(flushSize, bufferLength);\n        const bufferSubset = this._buffer.splice(0, batchSize);\n        this._putEvents(bufferSubset);\n    }\n    async _putEvents(buffer) {\n        const eventMap = this._bufferToMap(buffer);\n        const batchEventParams = this._generateBatchEventParams(eventMap);\n        try {\n            const { credentials, region, userAgentValue } = this._config;\n            const data = await putEvents({\n                credentials,\n                region,\n                userAgentValue,\n            }, batchEventParams);\n            this._processPutEventsSuccessResponse(data, eventMap);\n        }\n        catch (err) {\n            this._handlePutEventsFailure(err, eventMap);\n        }\n    }\n    _generateBatchEventParams(eventMap) {\n        const batchItem = {};\n        Object.values(eventMap).forEach(item => {\n            const { event, timestamp, endpointId, eventId, session } = item;\n            const { name, attributes, metrics } = event;\n            batchItem[endpointId] = {\n                Endpoint: {\n                    ...batchItem[endpointId]?.Endpoint,\n                },\n                Events: {\n                    ...batchItem[endpointId]?.Events,\n                    [eventId]: {\n                        EventType: name,\n                        Timestamp: new Date(timestamp).toISOString(),\n                        Attributes: attributes,\n                        Metrics: metrics,\n                        Session: session,\n                    },\n                },\n            };\n        });\n        return {\n            ApplicationId: this._config.appId,\n            EventsRequest: {\n                BatchItem: batchItem,\n            },\n        };\n    }\n    _handlePutEventsFailure(err, eventMap) {\n        logger.debug('putEvents call to Pinpoint failed.', err);\n        const statusCode = err.$metadata && err.$metadata.httpStatusCode;\n        if (RETRYABLE_CODES.includes(statusCode)) {\n            const retryableEvents = Object.values(eventMap);\n            this._retry(retryableEvents);\n        }\n    }\n    _processPutEventsSuccessResponse(data, eventMap) {\n        const { Results = {} } = data.EventsResponse ?? {};\n        const retryableEvents = [];\n        Object.entries(Results).forEach(([_, endpointValues]) => {\n            const responses = endpointValues.EventsItemResponse ?? {};\n            Object.entries(responses).forEach(([eventId, eventValues]) => {\n                const eventObject = eventMap[eventId];\n                if (!eventObject) {\n                    return;\n                }\n                const { StatusCode, Message } = eventValues ?? {};\n                if (StatusCode && ACCEPTED_CODES.includes(StatusCode)) {\n                    return;\n                }\n                if (StatusCode && RETRYABLE_CODES.includes(StatusCode)) {\n                    retryableEvents.push(eventObject);\n                    return;\n                }\n                const { name } = eventObject.event;\n                logger.warn('Pinpoint event failed to send.', {\n                    eventId,\n                    name,\n                    message: Message,\n                });\n            });\n        });\n        if (retryableEvents.length) {\n            this._retry(retryableEvents);\n        }\n    }\n    _retry(retryableEvents) {\n        // retryable events that haven't reached the resendLimit\n        const eligibleEvents = [];\n        retryableEvents.forEach((bufferedEvent) => {\n            const { eventId } = bufferedEvent;\n            const { name } = bufferedEvent.event;\n            if (bufferedEvent.resendLimit-- > 0) {\n                logger.debug('Resending event.', {\n                    eventId,\n                    name,\n                    remainingAttempts: bufferedEvent.resendLimit,\n                });\n                eligibleEvents.push({ [eventId]: bufferedEvent });\n                return;\n            }\n            logger.debug('No retry attempts remaining for event.', {\n                eventId,\n                name,\n            });\n        });\n        // add the events to the front of the buffer\n        this._buffer.unshift(...eligibleEvents);\n    }\n    _bufferToMap(buffer) {\n        return buffer.reduce((acc, curVal) => {\n            const [[key, value]] = Object.entries(curVal);\n            acc[key] = value;\n            return acc;\n        }, {});\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}