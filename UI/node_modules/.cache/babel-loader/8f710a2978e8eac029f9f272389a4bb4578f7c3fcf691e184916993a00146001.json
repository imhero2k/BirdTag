{"ast":null,"code":"import crc32 from 'crc-32';\nimport { hexToBase64 } from './hexUtils.mjs';\nimport { readFile } from './readFile.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst CHUNK_SIZE = 1024 * 1024; // 1MB chunks\n/**\n * Calculate the CRC32 checksum for given content and return base64 encoded checksum.\n */\nconst calculateContentCRC32 = async function (content) {\n  let seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let internalSeed = seed;\n  if (content instanceof ArrayBuffer || ArrayBuffer.isView(content)) {\n    let uint8Array;\n    if (content instanceof ArrayBuffer) {\n      uint8Array = new Uint8Array(content);\n    } else {\n      uint8Array = new Uint8Array(content.buffer, content.byteOffset, content.byteLength);\n    }\n    let offset = 0;\n    while (offset < uint8Array.length) {\n      const end = Math.min(offset + CHUNK_SIZE, uint8Array.length);\n      const chunk = uint8Array.slice(offset, end);\n      internalSeed = crc32.buf(chunk, internalSeed) >>> 0;\n      offset = end;\n    }\n  } else {\n    let blob;\n    if (content instanceof Blob) {\n      blob = content;\n    } else {\n      blob = new Blob([content]);\n    }\n    let offset = 0;\n    while (offset < blob.size) {\n      const end = Math.min(offset + CHUNK_SIZE, blob.size);\n      const chunk = blob.slice(offset, end);\n      const arrayBuffer = await readFile(chunk);\n      const uint8Array = new Uint8Array(arrayBuffer);\n      internalSeed = crc32.buf(uint8Array, internalSeed) >>> 0;\n      offset = end;\n    }\n  }\n  const hex = internalSeed.toString(16).padStart(8, '0');\n  return hexToBase64(hex);\n};\nexport { calculateContentCRC32 };","map":{"version":3,"names":["CHUNK_SIZE","calculateContentCRC32","content","seed","arguments","length","undefined","internalSeed","ArrayBuffer","isView","uint8Array","Uint8Array","buffer","byteOffset","byteLength","offset","end","Math","min","chunk","slice","crc32","buf","blob","Blob","size","arrayBuffer","readFile","hex","toString","padStart","hexToBase64"],"sources":["/Users/saisaran/Desktop/BirdTag/UI/node_modules/@aws-amplify/storage/src/providers/s3/utils/crc32.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport crc32 from 'crc-32';\nimport { hexToBase64 } from './hexUtils';\nimport { readFile } from './readFile';\nconst CHUNK_SIZE = 1024 * 1024; // 1MB chunks\n/**\n * Calculate the CRC32 checksum for given content and return base64 encoded checksum.\n */\nexport const calculateContentCRC32 = async (content, seed = 0) => {\n    let internalSeed = seed;\n    if (content instanceof ArrayBuffer || ArrayBuffer.isView(content)) {\n        let uint8Array;\n        if (content instanceof ArrayBuffer) {\n            uint8Array = new Uint8Array(content);\n        }\n        else {\n            uint8Array = new Uint8Array(content.buffer, content.byteOffset, content.byteLength);\n        }\n        let offset = 0;\n        while (offset < uint8Array.length) {\n            const end = Math.min(offset + CHUNK_SIZE, uint8Array.length);\n            const chunk = uint8Array.slice(offset, end);\n            internalSeed = crc32.buf(chunk, internalSeed) >>> 0;\n            offset = end;\n        }\n    }\n    else {\n        let blob;\n        if (content instanceof Blob) {\n            blob = content;\n        }\n        else {\n            blob = new Blob([content]);\n        }\n        let offset = 0;\n        while (offset < blob.size) {\n            const end = Math.min(offset + CHUNK_SIZE, blob.size);\n            const chunk = blob.slice(offset, end);\n            const arrayBuffer = await readFile(chunk);\n            const uint8Array = new Uint8Array(arrayBuffer);\n            internalSeed = crc32.buf(uint8Array, internalSeed) >>> 0;\n            offset = end;\n        }\n    }\n    const hex = internalSeed.toString(16).padStart(8, '0');\n    return hexToBase64(hex);\n};\n"],"mappings":";;;;AAAA;AACA;AAIA,MAAMA,UAAU,GAAG,IAAI,GAAG,IAAI,CAAC;AAC/B;AACA;AACA;AACY,MAACC,qBAAqB,GAAG,eAAAA,CAAOC,OAAO,EAAe;EAAA,IAAbC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EACzD,IAAIG,YAAY,GAAGJ,IAAI;EACvB,IAAID,OAAO,YAAYM,WAAW,IAAIA,WAAW,CAACC,MAAM,CAACP,OAAO,CAAC,EAAE;IAC/D,IAAIQ,UAAU;IACd,IAAIR,OAAO,YAAYM,WAAW,EAAE;MAChCE,UAAU,GAAG,IAAIC,UAAU,CAACT,OAAO,CAAC;IAChD,OACa;MACDQ,UAAU,GAAG,IAAIC,UAAU,CAACT,OAAO,CAACU,MAAM,EAAEV,OAAO,CAACW,UAAU,EAAEX,OAAO,CAACY,UAAU,CAAC;IAC/F;IACQ,IAAIC,MAAM,GAAG,CAAC;IACd,OAAOA,MAAM,GAAGL,UAAU,CAACL,MAAM,EAAE;MAC/B,MAAMW,GAAG,GAAGC,IAAI,CAACC,GAAG,CAACH,MAAM,GAAGf,UAAU,EAAEU,UAAU,CAACL,MAAM,CAAC;MAC5D,MAAMc,KAAK,GAAGT,UAAU,CAACU,KAAK,CAACL,MAAM,EAAEC,GAAG,CAAC;MAC3CT,YAAY,GAAGc,KAAK,CAACC,GAAG,CAACH,KAAK,EAAEZ,YAAY,CAAC,KAAK,CAAC;MACnDQ,MAAM,GAAGC,GAAG;IACxB;EACA,OACS;IACD,IAAIO,IAAI;IACR,IAAIrB,OAAO,YAAYsB,IAAI,EAAE;MACzBD,IAAI,GAAGrB,OAAO;IAC1B,OACa;MACDqB,IAAI,GAAG,IAAIC,IAAI,CAAC,CAACtB,OAAO,CAAC,CAAC;IACtC;IACQ,IAAIa,MAAM,GAAG,CAAC;IACd,OAAOA,MAAM,GAAGQ,IAAI,CAACE,IAAI,EAAE;MACvB,MAAMT,GAAG,GAAGC,IAAI,CAACC,GAAG,CAACH,MAAM,GAAGf,UAAU,EAAEuB,IAAI,CAACE,IAAI,CAAC;MACpD,MAAMN,KAAK,GAAGI,IAAI,CAACH,KAAK,CAACL,MAAM,EAAEC,GAAG,CAAC;MACrC,MAAMU,WAAW,GAAG,MAAMC,QAAQ,CAACR,KAAK,CAAC;MACzC,MAAMT,UAAU,GAAG,IAAIC,UAAU,CAACe,WAAW,CAAC;MAC9CnB,YAAY,GAAGc,KAAK,CAACC,GAAG,CAACZ,UAAU,EAAEH,YAAY,CAAC,KAAK,CAAC;MACxDQ,MAAM,GAAGC,GAAG;IACxB;EACA;EACI,MAAMY,GAAG,GAAGrB,YAAY,CAACsB,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;EACtD,OAAOC,WAAW,CAACH,GAAG,CAAC;AAC3B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}