{"ast":null,"code":"\"use client\";\n\n// src/slider.tsx\nimport _objectSpread from \"/Users/saisaran/Desktop/BirdTag/UI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/saisaran/Desktop/BirdTag/UI/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"name\", \"min\", \"max\", \"step\", \"orientation\", \"disabled\", \"minStepsBetweenThumbs\", \"defaultValue\", \"value\", \"onValueChange\", \"onValueCommit\", \"inverted\", \"form\"],\n  _excluded2 = [\"min\", \"max\", \"dir\", \"inverted\", \"onSlideStart\", \"onSlideMove\", \"onSlideEnd\", \"onStepKeyDown\"],\n  _excluded3 = [\"min\", \"max\", \"inverted\", \"onSlideStart\", \"onSlideMove\", \"onSlideEnd\", \"onStepKeyDown\"],\n  _excluded4 = [\"__scopeSlider\", \"onSlideStart\", \"onSlideMove\", \"onSlideEnd\", \"onHomeKeyDown\", \"onEndKeyDown\", \"onStepKeyDown\"],\n  _excluded5 = [\"__scopeSlider\"],\n  _excluded6 = [\"__scopeSlider\"],\n  _excluded7 = [\"__scopeSlider\", \"index\", \"name\"],\n  _excluded8 = [\"__scopeSlider\", \"value\"];\nimport * as React from \"react\";\nimport { clamp } from \"@radix-ui/number\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { usePrevious } from \"@radix-ui/react-use-previous\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar PAGE_KEYS = [\"PageUp\", \"PageDown\"];\nvar ARROW_KEYS = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\nvar BACK_KEYS = {\n  \"from-left\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-right\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowRight\"],\n  \"from-bottom\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-top\": [\"Home\", \"PageDown\", \"ArrowUp\", \"ArrowLeft\"]\n};\nvar SLIDER_NAME = \"Slider\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(SLIDER_NAME);\nvar [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [createCollectionScope]);\nvar [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);\nvar Slider = React.forwardRef((props, forwardedRef) => {\n  const {\n      name,\n      min = 0,\n      max = 100,\n      step = 1,\n      orientation = \"horizontal\",\n      disabled = false,\n      minStepsBetweenThumbs = 0,\n      defaultValue = [min],\n      value,\n      onValueChange = () => {},\n      onValueCommit = () => {},\n      inverted = false,\n      form\n    } = props,\n    sliderProps = _objectWithoutProperties(props, _excluded);\n  const thumbRefs = React.useRef(/* @__PURE__ */new Set());\n  const valueIndexToChangeRef = React.useRef(0);\n  const isHorizontal = orientation === \"horizontal\";\n  const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;\n  const [values = [], setValues] = useControllableState({\n    prop: value,\n    defaultProp: defaultValue,\n    onChange: value2 => {\n      var _thumbs$valueIndexToC;\n      const thumbs = [...thumbRefs.current];\n      (_thumbs$valueIndexToC = thumbs[valueIndexToChangeRef.current]) === null || _thumbs$valueIndexToC === void 0 || _thumbs$valueIndexToC.focus();\n      onValueChange(value2);\n    }\n  });\n  const valuesBeforeSlideStartRef = React.useRef(values);\n  function handleSlideStart(value2) {\n    const closestIndex = getClosestValueIndex(values, value2);\n    updateValues(value2, closestIndex);\n  }\n  function handleSlideMove(value2) {\n    updateValues(value2, valueIndexToChangeRef.current);\n  }\n  function handleSlideEnd() {\n    const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];\n    const nextValue = values[valueIndexToChangeRef.current];\n    const hasChanged = nextValue !== prevValue;\n    if (hasChanged) onValueCommit(values);\n  }\n  function updateValues(value2, atIndex) {\n    let {\n      commit\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      commit: false\n    };\n    const decimalCount = getDecimalCount(step);\n    const snapToStep = roundValue(Math.round((value2 - min) / step) * step + min, decimalCount);\n    const nextValue = clamp(snapToStep, [min, max]);\n    setValues(function () {\n      let prevValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n      if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n        valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n        const hasChanged = String(nextValues) !== String(prevValues);\n        if (hasChanged && commit) onValueCommit(nextValues);\n        return hasChanged ? nextValues : prevValues;\n      } else {\n        return prevValues;\n      }\n    });\n  }\n  return /* @__PURE__ */jsx(SliderProvider, {\n    scope: props.__scopeSlider,\n    name,\n    disabled,\n    min,\n    max,\n    valueIndexToChangeRef,\n    thumbs: thumbRefs.current,\n    values,\n    orientation,\n    form,\n    children: /* @__PURE__ */jsx(Collection.Provider, {\n      scope: props.__scopeSlider,\n      children: /* @__PURE__ */jsx(Collection.Slot, {\n        scope: props.__scopeSlider,\n        children: /* @__PURE__ */jsx(SliderOrientation, _objectSpread(_objectSpread({\n          \"aria-disabled\": disabled,\n          \"data-disabled\": disabled ? \"\" : void 0\n        }, sliderProps), {}, {\n          ref: forwardedRef,\n          onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {\n            if (!disabled) valuesBeforeSlideStartRef.current = values;\n          }),\n          min,\n          max,\n          inverted,\n          onSlideStart: disabled ? void 0 : handleSlideStart,\n          onSlideMove: disabled ? void 0 : handleSlideMove,\n          onSlideEnd: disabled ? void 0 : handleSlideEnd,\n          onHomeKeyDown: () => !disabled && updateValues(min, 0, {\n            commit: true\n          }),\n          onEndKeyDown: () => !disabled && updateValues(max, values.length - 1, {\n            commit: true\n          }),\n          onStepKeyDown: _ref => {\n            let {\n              event,\n              direction: stepDirection\n            } = _ref;\n            if (!disabled) {\n              const isPageKey = PAGE_KEYS.includes(event.key);\n              const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);\n              const multiplier = isSkipKey ? 10 : 1;\n              const atIndex = valueIndexToChangeRef.current;\n              const value2 = values[atIndex];\n              const stepInDirection = step * multiplier * stepDirection;\n              updateValues(value2 + stepInDirection, atIndex, {\n                commit: true\n              });\n            }\n          }\n        }))\n      })\n    })\n  });\n});\nSlider.displayName = SLIDER_NAME;\nvar [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {\n  startEdge: \"left\",\n  endEdge: \"right\",\n  size: \"width\",\n  direction: 1\n});\nvar SliderHorizontal = React.forwardRef((props, forwardedRef) => {\n  const {\n      min,\n      max,\n      dir,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown\n    } = props,\n    sliderProps = _objectWithoutProperties(props, _excluded2);\n  const [slider, setSlider] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setSlider(node));\n  const rectRef = React.useRef(void 0);\n  const direction = useDirection(dir);\n  const isDirectionLTR = direction === \"ltr\";\n  const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;\n  function getValueFromPointer(pointerPosition) {\n    const rect = rectRef.current || slider.getBoundingClientRect();\n    const input = [0, rect.width];\n    const output = isSlidingFromLeft ? [min, max] : [max, min];\n    const value = linearScale(input, output);\n    rectRef.current = rect;\n    return value(pointerPosition - rect.left);\n  }\n  return /* @__PURE__ */jsx(SliderOrientationProvider, {\n    scope: props.__scopeSlider,\n    startEdge: isSlidingFromLeft ? \"left\" : \"right\",\n    endEdge: isSlidingFromLeft ? \"right\" : \"left\",\n    direction: isSlidingFromLeft ? 1 : -1,\n    size: \"width\",\n    children: /* @__PURE__ */jsx(SliderImpl, _objectSpread(_objectSpread({\n      dir: direction,\n      \"data-orientation\": \"horizontal\"\n    }, sliderProps), {}, {\n      ref: composedRefs,\n      style: _objectSpread(_objectSpread({}, sliderProps.style), {}, {\n        [\"--radix-slider-thumb-transform\"]: \"translateX(-50%)\"\n      }),\n      onSlideStart: event => {\n        const value = getValueFromPointer(event.clientX);\n        onSlideStart === null || onSlideStart === void 0 || onSlideStart(value);\n      },\n      onSlideMove: event => {\n        const value = getValueFromPointer(event.clientX);\n        onSlideMove === null || onSlideMove === void 0 || onSlideMove(value);\n      },\n      onSlideEnd: () => {\n        rectRef.current = void 0;\n        onSlideEnd === null || onSlideEnd === void 0 || onSlideEnd();\n      },\n      onStepKeyDown: event => {\n        const slideDirection = isSlidingFromLeft ? \"from-left\" : \"from-right\";\n        const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n        onStepKeyDown === null || onStepKeyDown === void 0 || onStepKeyDown({\n          event,\n          direction: isBackKey ? -1 : 1\n        });\n      }\n    }))\n  });\n});\nvar SliderVertical = React.forwardRef((props, forwardedRef) => {\n  const {\n      min,\n      max,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown\n    } = props,\n    sliderProps = _objectWithoutProperties(props, _excluded3);\n  const sliderRef = React.useRef(null);\n  const ref = useComposedRefs(forwardedRef, sliderRef);\n  const rectRef = React.useRef(void 0);\n  const isSlidingFromBottom = !inverted;\n  function getValueFromPointer(pointerPosition) {\n    const rect = rectRef.current || sliderRef.current.getBoundingClientRect();\n    const input = [0, rect.height];\n    const output = isSlidingFromBottom ? [max, min] : [min, max];\n    const value = linearScale(input, output);\n    rectRef.current = rect;\n    return value(pointerPosition - rect.top);\n  }\n  return /* @__PURE__ */jsx(SliderOrientationProvider, {\n    scope: props.__scopeSlider,\n    startEdge: isSlidingFromBottom ? \"bottom\" : \"top\",\n    endEdge: isSlidingFromBottom ? \"top\" : \"bottom\",\n    size: \"height\",\n    direction: isSlidingFromBottom ? 1 : -1,\n    children: /* @__PURE__ */jsx(SliderImpl, _objectSpread(_objectSpread({\n      \"data-orientation\": \"vertical\"\n    }, sliderProps), {}, {\n      ref,\n      style: _objectSpread(_objectSpread({}, sliderProps.style), {}, {\n        [\"--radix-slider-thumb-transform\"]: \"translateY(50%)\"\n      }),\n      onSlideStart: event => {\n        const value = getValueFromPointer(event.clientY);\n        onSlideStart === null || onSlideStart === void 0 || onSlideStart(value);\n      },\n      onSlideMove: event => {\n        const value = getValueFromPointer(event.clientY);\n        onSlideMove === null || onSlideMove === void 0 || onSlideMove(value);\n      },\n      onSlideEnd: () => {\n        rectRef.current = void 0;\n        onSlideEnd === null || onSlideEnd === void 0 || onSlideEnd();\n      },\n      onStepKeyDown: event => {\n        const slideDirection = isSlidingFromBottom ? \"from-bottom\" : \"from-top\";\n        const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n        onStepKeyDown === null || onStepKeyDown === void 0 || onStepKeyDown({\n          event,\n          direction: isBackKey ? -1 : 1\n        });\n      }\n    }))\n  });\n});\nvar SliderImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeSlider,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onHomeKeyDown,\n      onEndKeyDown,\n      onStepKeyDown\n    } = props,\n    sliderProps = _objectWithoutProperties(props, _excluded4);\n  const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n  return /* @__PURE__ */jsx(Primitive.span, _objectSpread(_objectSpread({}, sliderProps), {}, {\n    ref: forwardedRef,\n    onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n      if (event.key === \"Home\") {\n        onHomeKeyDown(event);\n        event.preventDefault();\n      } else if (event.key === \"End\") {\n        onEndKeyDown(event);\n        event.preventDefault();\n      } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n        onStepKeyDown(event);\n        event.preventDefault();\n      }\n    }),\n    onPointerDown: composeEventHandlers(props.onPointerDown, event => {\n      const target = event.target;\n      target.setPointerCapture(event.pointerId);\n      event.preventDefault();\n      if (context.thumbs.has(target)) {\n        target.focus();\n      } else {\n        onSlideStart(event);\n      }\n    }),\n    onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n      const target = event.target;\n      if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);\n    }),\n    onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n      const target = event.target;\n      if (target.hasPointerCapture(event.pointerId)) {\n        target.releasePointerCapture(event.pointerId);\n        onSlideEnd(event);\n      }\n    })\n  }));\n});\nvar TRACK_NAME = \"SliderTrack\";\nvar SliderTrack = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeSlider\n    } = props,\n    trackProps = _objectWithoutProperties(props, _excluded5);\n  const context = useSliderContext(TRACK_NAME, __scopeSlider);\n  return /* @__PURE__ */jsx(Primitive.span, _objectSpread(_objectSpread({\n    \"data-disabled\": context.disabled ? \"\" : void 0,\n    \"data-orientation\": context.orientation\n  }, trackProps), {}, {\n    ref: forwardedRef\n  }));\n});\nSliderTrack.displayName = TRACK_NAME;\nvar RANGE_NAME = \"SliderRange\";\nvar SliderRange = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeSlider\n    } = props,\n    rangeProps = _objectWithoutProperties(props, _excluded6);\n  const context = useSliderContext(RANGE_NAME, __scopeSlider);\n  const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const valuesCount = context.values.length;\n  const percentages = context.values.map(value => convertValueToPercentage(value, context.min, context.max));\n  const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n  const offsetEnd = 100 - Math.max(...percentages);\n  return /* @__PURE__ */jsx(Primitive.span, _objectSpread(_objectSpread({\n    \"data-orientation\": context.orientation,\n    \"data-disabled\": context.disabled ? \"\" : void 0\n  }, rangeProps), {}, {\n    ref: composedRefs,\n    style: _objectSpread(_objectSpread({}, props.style), {}, {\n      [orientation.startEdge]: offsetStart + \"%\",\n      [orientation.endEdge]: offsetEnd + \"%\"\n    })\n  }));\n});\nSliderRange.displayName = RANGE_NAME;\nvar THUMB_NAME = \"SliderThumb\";\nvar SliderThumb = React.forwardRef((props, forwardedRef) => {\n  const getItems = useCollection(props.__scopeSlider);\n  const [thumb, setThumb] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setThumb(node));\n  const index = React.useMemo(() => thumb ? getItems().findIndex(item => item.ref.current === thumb) : -1, [getItems, thumb]);\n  return /* @__PURE__ */jsx(SliderThumbImpl, _objectSpread(_objectSpread({}, props), {}, {\n    ref: composedRefs,\n    index\n  }));\n});\nvar SliderThumbImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeSlider,\n      index,\n      name\n    } = props,\n    thumbProps = _objectWithoutProperties(props, _excluded7);\n  const context = useSliderContext(THUMB_NAME, __scopeSlider);\n  const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n  const [thumb, setThumb] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setThumb(node));\n  const isFormControl = thumb ? context.form || !!thumb.closest(\"form\") : true;\n  const size = useSize(thumb);\n  const value = context.values[index];\n  const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);\n  const label = getLabel(index, context.values.length);\n  const orientationSize = size === null || size === void 0 ? void 0 : size[orientation.size];\n  const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;\n  React.useEffect(() => {\n    if (thumb) {\n      context.thumbs.add(thumb);\n      return () => {\n        context.thumbs.delete(thumb);\n      };\n    }\n  }, [thumb, context.thumbs]);\n  return /* @__PURE__ */jsxs(\"span\", {\n    style: {\n      transform: \"var(--radix-slider-thumb-transform)\",\n      position: \"absolute\",\n      [orientation.startEdge]: \"calc(\".concat(percent, \"% + \").concat(thumbInBoundsOffset, \"px)\")\n    },\n    children: [/* @__PURE__ */jsx(Collection.ItemSlot, {\n      scope: props.__scopeSlider,\n      children: /* @__PURE__ */jsx(Primitive.span, _objectSpread(_objectSpread({\n        role: \"slider\",\n        \"aria-label\": props[\"aria-label\"] || label,\n        \"aria-valuemin\": context.min,\n        \"aria-valuenow\": value,\n        \"aria-valuemax\": context.max,\n        \"aria-orientation\": context.orientation,\n        \"data-orientation\": context.orientation,\n        \"data-disabled\": context.disabled ? \"\" : void 0,\n        tabIndex: context.disabled ? void 0 : 0\n      }, thumbProps), {}, {\n        ref: composedRefs,\n        style: value === void 0 ? {\n          display: \"none\"\n        } : props.style,\n        onFocus: composeEventHandlers(props.onFocus, () => {\n          context.valueIndexToChangeRef.current = index;\n        })\n      }))\n    }), isFormControl && /* @__PURE__ */jsx(SliderBubbleInput, {\n      name: name !== null && name !== void 0 ? name : context.name ? context.name + (context.values.length > 1 ? \"[]\" : \"\") : void 0,\n      form: context.form,\n      value\n    }, index)]\n  });\n});\nSliderThumb.displayName = THUMB_NAME;\nvar BUBBLE_INPUT_NAME = \"RadioBubbleInput\";\nvar SliderBubbleInput = React.forwardRef((_ref2, forwardedRef) => {\n  let {\n      __scopeSlider,\n      value\n    } = _ref2,\n    props = _objectWithoutProperties(_ref2, _excluded8);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(ref, forwardedRef);\n  const prevValue = usePrevious(value);\n  React.useEffect(() => {\n    const input = ref.current;\n    if (!input) return;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, \"value\");\n    const setValue = descriptor.set;\n    if (prevValue !== value && setValue) {\n      const event = new Event(\"input\", {\n        bubbles: true\n      });\n      setValue.call(input, value);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value]);\n  return /* @__PURE__ */jsx(Primitive.input, _objectSpread(_objectSpread({\n    style: {\n      display: \"none\"\n    }\n  }, props), {}, {\n    ref: composedRefs,\n    defaultValue: value\n  }));\n});\nSliderBubbleInput.displayName = BUBBLE_INPUT_NAME;\nfunction getNextSortedValues() {\n  let prevValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let nextValue = arguments.length > 1 ? arguments[1] : undefined;\n  let atIndex = arguments.length > 2 ? arguments[2] : undefined;\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\nfunction convertValueToPercentage(value, min, max) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  const percentage = percentPerStep * (value - min);\n  return clamp(percentage, [0, 100]);\n}\nfunction getLabel(index, totalValues) {\n  if (totalValues > 2) {\n    return \"Value \".concat(index + 1, \" of \").concat(totalValues);\n  } else if (totalValues === 2) {\n    return [\"Minimum\", \"Maximum\"][index];\n  } else {\n    return void 0;\n  }\n}\nfunction getClosestValueIndex(values, nextValue) {\n  if (values.length === 1) return 0;\n  const distances = values.map(value => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\nfunction getThumbInBoundsOffset(width, left, direction) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\nfunction getStepsBetweenValues(values) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value);\n}\nfunction hasMinStepsBetweenValues(values, minStepsBetweenValues) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n  return true;\n}\nfunction linearScale(input, output) {\n  return value => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\nfunction getDecimalCount(value) {\n  return (String(value).split(\".\")[1] || \"\").length;\n}\nfunction roundValue(value, decimalCount) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\nvar Root = Slider;\nvar Track = SliderTrack;\nvar Range = SliderRange;\nvar Thumb = SliderThumb;\nexport { Range, Root, Slider, SliderRange, SliderThumb, SliderTrack, Thumb, Track, createSliderScope };","map":{"version":3,"names":["React","clamp","composeEventHandlers","useComposedRefs","createContextScope","useControllableState","useDirection","usePrevious","useSize","Primitive","createCollection","jsx","jsxs","PAGE_KEYS","ARROW_KEYS","BACK_KEYS","SLIDER_NAME","Collection","useCollection","createCollectionScope","createSliderContext","createSliderScope","SliderProvider","useSliderContext","Slider","forwardRef","props","forwardedRef","name","min","max","step","orientation","disabled","minStepsBetweenThumbs","defaultValue","value","onValueChange","onValueCommit","inverted","form","sliderProps","_objectWithoutProperties","_excluded","thumbRefs","useRef","Set","valueIndexToChangeRef","isHorizontal","SliderOrientation","SliderHorizontal","SliderVertical","values","setValues","prop","defaultProp","onChange","value2","_thumbs$valueIndexToC","thumbs","current","focus","valuesBeforeSlideStartRef","handleSlideStart","closestIndex","getClosestValueIndex","updateValues","handleSlideMove","handleSlideEnd","prevValue","nextValue","hasChanged","atIndex","commit","arguments","length","undefined","decimalCount","getDecimalCount","snapToStep","roundValue","Math","round","prevValues","nextValues","getNextSortedValues","hasMinStepsBetweenValues","indexOf","String","scope","__scopeSlider","children","Provider","Slot","_objectSpread","ref","onPointerDown","onSlideStart","onSlideMove","onSlideEnd","onHomeKeyDown","onEndKeyDown","onStepKeyDown","_ref","event","direction","stepDirection","isPageKey","includes","key","isSkipKey","shiftKey","multiplier","stepInDirection","displayName","SliderOrientationProvider","useSliderOrientationContext","startEdge","endEdge","size","dir","_excluded2","slider","setSlider","useState","composedRefs","node","rectRef","isDirectionLTR","isSlidingFromLeft","getValueFromPointer","pointerPosition","rect","getBoundingClientRect","input","width","output","linearScale","left","SliderImpl","style","clientX","slideDirection","isBackKey","_excluded3","sliderRef","isSlidingFromBottom","height","top","clientY","_excluded4","context","span","onKeyDown","preventDefault","concat","target","setPointerCapture","pointerId","has","onPointerMove","hasPointerCapture","onPointerUp","releasePointerCapture","TRACK_NAME","SliderTrack","trackProps","_excluded5","RANGE_NAME","SliderRange","rangeProps","_excluded6","valuesCount","percentages","map","convertValueToPercentage","offsetStart","offsetEnd","THUMB_NAME","SliderThumb","getItems","thumb","setThumb","index","useMemo","findIndex","item","SliderThumbImpl","thumbProps","_excluded7","isFormControl","closest","percent","label","getLabel","orientationSize","thumbInBoundsOffset","getThumbInBoundsOffset","useEffect","add","delete","transform","position","ItemSlot","role","tabIndex","display","onFocus","SliderBubbleInput","BUBBLE_INPUT_NAME","_ref2","_excluded8","inputProto","window","HTMLInputElement","prototype","descriptor","Object","getOwnPropertyDescriptor","setValue","set","Event","bubbles","call","dispatchEvent","sort","a","b","maxSteps","percentPerStep","percentage","totalValues","distances","abs","closestDistance","halfWidth","halfPercent","offset","getStepsBetweenValues","slice","minStepsBetweenValues","stepsBetweenValues","actualMinStepsBetweenValues","ratio","split","rounder","pow","Root","Track","Range","Thumb"],"sources":["/Users/saisaran/Desktop/BirdTag/UI/node_modules/@radix-ui/react-slider/src/slider.tsx"],"sourcesContent":["import * as React from 'react';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createCollection } from '@radix-ui/react-collection';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst PAGE_KEYS = ['PageUp', 'PageDown'];\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\ntype SlideDirection = 'from-left' | 'from-right' | 'from-bottom' | 'from-top';\nconst BACK_KEYS: Record<SlideDirection, string[]> = {\n  'from-left': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-right': ['Home', 'PageDown', 'ArrowDown', 'ArrowRight'],\n  'from-bottom': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-top': ['Home', 'PageDown', 'ArrowUp', 'ArrowLeft'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Slider\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLIDER_NAME = 'Slider';\n\nconst [Collection, useCollection, createCollectionScope] =\n  createCollection<SliderThumbElement>(SLIDER_NAME);\n\ntype ScopedProps<P> = P & { __scopeSlider?: Scope };\nconst [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [\n  createCollectionScope,\n]);\n\ntype SliderContextValue = {\n  name: string | undefined;\n  disabled: boolean | undefined;\n  min: number;\n  max: number;\n  values: number[];\n  valueIndexToChangeRef: React.MutableRefObject<number>;\n  thumbs: Set<SliderThumbElement>;\n  orientation: SliderProps['orientation'];\n  form: string | undefined;\n};\n\nconst [SliderProvider, useSliderContext] = createSliderContext<SliderContextValue>(SLIDER_NAME);\n\ntype SliderElement = SliderHorizontalElement | SliderVerticalElement;\ninterface SliderProps\n  extends Omit<\n    SliderHorizontalProps | SliderVerticalProps,\n    keyof SliderOrientationPrivateProps | 'defaultValue'\n  > {\n  name?: string;\n  disabled?: boolean;\n  orientation?: React.AriaAttributes['aria-orientation'];\n  dir?: Direction;\n  min?: number;\n  max?: number;\n  step?: number;\n  minStepsBetweenThumbs?: number;\n  value?: number[];\n  defaultValue?: number[];\n  onValueChange?(value: number[]): void;\n  onValueCommit?(value: number[]): void;\n  inverted?: boolean;\n  form?: string;\n}\n\nconst Slider = React.forwardRef<SliderElement, SliderProps>(\n  (props: ScopedProps<SliderProps>, forwardedRef) => {\n    const {\n      name,\n      min = 0,\n      max = 100,\n      step = 1,\n      orientation = 'horizontal',\n      disabled = false,\n      minStepsBetweenThumbs = 0,\n      defaultValue = [min],\n      value,\n      onValueChange = () => {},\n      onValueCommit = () => {},\n      inverted = false,\n      form,\n      ...sliderProps\n    } = props;\n    const thumbRefs = React.useRef<SliderContextValue['thumbs']>(new Set());\n    const valueIndexToChangeRef = React.useRef<number>(0);\n    const isHorizontal = orientation === 'horizontal';\n    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;\n\n    const [values = [], setValues] = useControllableState({\n      prop: value,\n      defaultProp: defaultValue,\n      onChange: (value) => {\n        const thumbs = [...thumbRefs.current];\n        thumbs[valueIndexToChangeRef.current]?.focus();\n        onValueChange(value);\n      },\n    });\n    const valuesBeforeSlideStartRef = React.useRef(values);\n\n    function handleSlideStart(value: number) {\n      const closestIndex = getClosestValueIndex(values, value);\n      updateValues(value, closestIndex);\n    }\n\n    function handleSlideMove(value: number) {\n      updateValues(value, valueIndexToChangeRef.current);\n    }\n\n    function handleSlideEnd() {\n      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];\n      const nextValue = values[valueIndexToChangeRef.current];\n      const hasChanged = nextValue !== prevValue;\n      if (hasChanged) onValueCommit(values);\n    }\n\n    function updateValues(value: number, atIndex: number, { commit } = { commit: false }) {\n      const decimalCount = getDecimalCount(step);\n      const snapToStep = roundValue(Math.round((value - min) / step) * step + min, decimalCount);\n      const nextValue = clamp(snapToStep, [min, max]);\n\n      setValues((prevValues = []) => {\n        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n          const hasChanged = String(nextValues) !== String(prevValues);\n          if (hasChanged && commit) onValueCommit(nextValues);\n          return hasChanged ? nextValues : prevValues;\n        } else {\n          return prevValues;\n        }\n      });\n    }\n\n    return (\n      <SliderProvider\n        scope={props.__scopeSlider}\n        name={name}\n        disabled={disabled}\n        min={min}\n        max={max}\n        valueIndexToChangeRef={valueIndexToChangeRef}\n        thumbs={thumbRefs.current}\n        values={values}\n        orientation={orientation}\n        form={form}\n      >\n        <Collection.Provider scope={props.__scopeSlider}>\n          <Collection.Slot scope={props.__scopeSlider}>\n            <SliderOrientation\n              aria-disabled={disabled}\n              data-disabled={disabled ? '' : undefined}\n              {...sliderProps}\n              ref={forwardedRef}\n              onPointerDown={composeEventHandlers(sliderProps.onPointerDown, () => {\n                if (!disabled) valuesBeforeSlideStartRef.current = values;\n              })}\n              min={min}\n              max={max}\n              inverted={inverted}\n              onSlideStart={disabled ? undefined : handleSlideStart}\n              onSlideMove={disabled ? undefined : handleSlideMove}\n              onSlideEnd={disabled ? undefined : handleSlideEnd}\n              onHomeKeyDown={() => !disabled && updateValues(min, 0, { commit: true })}\n              onEndKeyDown={() =>\n                !disabled && updateValues(max, values.length - 1, { commit: true })\n              }\n              onStepKeyDown={({ event, direction: stepDirection }) => {\n                if (!disabled) {\n                  const isPageKey = PAGE_KEYS.includes(event.key);\n                  const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\n                  const multiplier = isSkipKey ? 10 : 1;\n                  const atIndex = valueIndexToChangeRef.current;\n                  const value = values[atIndex]!;\n                  const stepInDirection = step * multiplier * stepDirection;\n                  updateValues(value + stepInDirection, atIndex, { commit: true });\n                }\n              }}\n            />\n          </Collection.Slot>\n        </Collection.Provider>\n      </SliderProvider>\n    );\n  }\n);\n\nSlider.displayName = SLIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderHorizontal\n * -----------------------------------------------------------------------------------------------*/\n\ntype Side = 'top' | 'right' | 'bottom' | 'left';\n\nconst [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext<{\n  startEdge: Side;\n  endEdge: Side;\n  size: keyof NonNullable<ReturnType<typeof useSize>>;\n  direction: number;\n}>(SLIDER_NAME, {\n  startEdge: 'left',\n  endEdge: 'right',\n  size: 'width',\n  direction: 1,\n});\n\ntype SliderOrientationPrivateProps = {\n  min: number;\n  max: number;\n  inverted: boolean;\n  onSlideStart?(value: number): void;\n  onSlideMove?(value: number): void;\n  onSlideEnd?(): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(step: { event: React.KeyboardEvent; direction: number }): void;\n};\ninterface SliderOrientationProps\n  extends Omit<SliderImplProps, keyof SliderImplPrivateProps>,\n    SliderOrientationPrivateProps {}\n\ntype SliderHorizontalElement = SliderImplElement;\ninterface SliderHorizontalProps extends SliderOrientationProps {\n  dir?: Direction;\n}\n\nconst SliderHorizontal = React.forwardRef<SliderHorizontalElement, SliderHorizontalProps>(\n  (props: ScopedProps<SliderHorizontalProps>, forwardedRef) => {\n    const {\n      min,\n      max,\n      dir,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const [slider, setSlider] = React.useState<SliderImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const rectRef = React.useRef<DOMRect>(undefined);\n    const direction = useDirection(dir);\n    const isDirectionLTR = direction === 'ltr';\n    const isSlidingFromLeft = (isDirectionLTR && !inverted) || (!isDirectionLTR && inverted);\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || slider!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.width];\n      const output: [number, number] = isSlidingFromLeft ? [min, max] : [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.left);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isSlidingFromLeft ? 'left' : 'right'}\n        endEdge={isSlidingFromLeft ? 'right' : 'left'}\n        direction={isSlidingFromLeft ? 1 : -1}\n        size=\"width\"\n      >\n        <SliderImpl\n          dir={direction}\n          data-orientation=\"horizontal\"\n          {...sliderProps}\n          ref={composedRefs}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateX(-50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => {\n            rectRef.current = undefined;\n            onSlideEnd?.();\n          }}\n          onStepKeyDown={(event) => {\n            const slideDirection = isSlidingFromLeft ? 'from-left' : 'from-right';\n            const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderVertical\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderVerticalElement = SliderImplElement;\ninterface SliderVerticalProps extends SliderOrientationProps {}\n\nconst SliderVertical = React.forwardRef<SliderVerticalElement, SliderVerticalProps>(\n  (props: ScopedProps<SliderVerticalProps>, forwardedRef) => {\n    const {\n      min,\n      max,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const sliderRef = React.useRef<SliderImplElement>(null);\n    const ref = useComposedRefs(forwardedRef, sliderRef);\n    const rectRef = React.useRef<DOMRect>(undefined);\n    const isSlidingFromBottom = !inverted;\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || sliderRef.current!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.height];\n      const output: [number, number] = isSlidingFromBottom ? [max, min] : [min, max];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.top);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isSlidingFromBottom ? 'bottom' : 'top'}\n        endEdge={isSlidingFromBottom ? 'top' : 'bottom'}\n        size=\"height\"\n        direction={isSlidingFromBottom ? 1 : -1}\n      >\n        <SliderImpl\n          data-orientation=\"vertical\"\n          {...sliderProps}\n          ref={ref}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateY(50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => {\n            rectRef.current = undefined;\n            onSlideEnd?.();\n          }}\n          onStepKeyDown={(event) => {\n            const slideDirection = isSlidingFromBottom ? 'from-bottom' : 'from-top';\n            const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderImpl\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderImplElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ntype SliderImplPrivateProps = {\n  onSlideStart(event: React.PointerEvent): void;\n  onSlideMove(event: React.PointerEvent): void;\n  onSlideEnd(event: React.PointerEvent): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(event: React.KeyboardEvent): void;\n};\ninterface SliderImplProps extends PrimitiveDivProps, SliderImplPrivateProps {}\n\nconst SliderImpl = React.forwardRef<SliderImplElement, SliderImplProps>(\n  (props: ScopedProps<SliderImplProps>, forwardedRef) => {\n    const {\n      __scopeSlider,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onHomeKeyDown,\n      onEndKeyDown,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n\n    return (\n      <Primitive.span\n        {...sliderProps}\n        ref={forwardedRef}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (event.key === 'Home') {\n            onHomeKeyDown(event);\n            // Prevent scrolling to page start\n            event.preventDefault();\n          } else if (event.key === 'End') {\n            onEndKeyDown(event);\n            // Prevent scrolling to page end\n            event.preventDefault();\n          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n            onStepKeyDown(event);\n            // Prevent scrolling for directional key presses\n            event.preventDefault();\n          }\n        })}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const target = event.target as HTMLElement;\n          target.setPointerCapture(event.pointerId);\n          // Prevent browser focus behaviour because we focus a thumb manually when values change.\n          event.preventDefault();\n          // Touch devices have a delay before focusing so won't focus if touch immediately moves\n          // away from target (sliding). We want thumb to focus regardless.\n          if (context.thumbs.has(target)) {\n            target.focus();\n          } else {\n            onSlideStart(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);\n        })}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n            onSlideEnd(event);\n          }\n        })}\n      />\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderTrack\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRACK_NAME = 'SliderTrack';\n\ntype SliderTrackElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SliderTrackProps extends PrimitiveSpanProps {}\n\nconst SliderTrack = React.forwardRef<SliderTrackElement, SliderTrackProps>(\n  (props: ScopedProps<SliderTrackProps>, forwardedRef) => {\n    const { __scopeSlider, ...trackProps } = props;\n    const context = useSliderContext(TRACK_NAME, __scopeSlider);\n    return (\n      <Primitive.span\n        data-disabled={context.disabled ? '' : undefined}\n        data-orientation={context.orientation}\n        {...trackProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSliderTrack.displayName = TRACK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderRange\n * -----------------------------------------------------------------------------------------------*/\n\nconst RANGE_NAME = 'SliderRange';\n\ntype SliderRangeElement = React.ComponentRef<typeof Primitive.span>;\ninterface SliderRangeProps extends PrimitiveSpanProps {}\n\nconst SliderRange = React.forwardRef<SliderRangeElement, SliderRangeProps>(\n  (props: ScopedProps<SliderRangeProps>, forwardedRef) => {\n    const { __scopeSlider, ...rangeProps } = props;\n    const context = useSliderContext(RANGE_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n    const ref = React.useRef<HTMLSpanElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const valuesCount = context.values.length;\n    const percentages = context.values.map((value) =>\n      convertValueToPercentage(value, context.min, context.max)\n    );\n    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n    const offsetEnd = 100 - Math.max(...percentages);\n\n    return (\n      <Primitive.span\n        data-orientation={context.orientation}\n        data-disabled={context.disabled ? '' : undefined}\n        {...rangeProps}\n        ref={composedRefs}\n        style={{\n          ...props.style,\n          [orientation.startEdge]: offsetStart + '%',\n          [orientation.endEdge]: offsetEnd + '%',\n        }}\n      />\n    );\n  }\n);\n\nSliderRange.displayName = RANGE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SliderThumb';\n\ntype SliderThumbElement = SliderThumbImplElement;\ninterface SliderThumbProps extends Omit<SliderThumbImplProps, 'index'> {}\n\nconst SliderThumb = React.forwardRef<SliderThumbElement, SliderThumbProps>(\n  (props: ScopedProps<SliderThumbProps>, forwardedRef) => {\n    const getItems = useCollection(props.__scopeSlider);\n    const [thumb, setThumb] = React.useState<SliderThumbImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const index = React.useMemo(\n      () => (thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1),\n      [getItems, thumb]\n    );\n    return <SliderThumbImpl {...props} ref={composedRefs} index={index} />;\n  }\n);\n\ntype SliderThumbImplElement = React.ComponentRef<typeof Primitive.span>;\ninterface SliderThumbImplProps extends PrimitiveSpanProps {\n  index: number;\n  name?: string;\n}\n\nconst SliderThumbImpl = React.forwardRef<SliderThumbImplElement, SliderThumbImplProps>(\n  (props: ScopedProps<SliderThumbImplProps>, forwardedRef) => {\n    const { __scopeSlider, index, name, ...thumbProps } = props;\n    const context = useSliderContext(THUMB_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n    const [thumb, setThumb] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = thumb ? context.form || !!thumb.closest('form') : true;\n    const size = useSize(thumb);\n    // We cast because index could be `-1` which would return undefined\n    const value = context.values[index] as number | undefined;\n    const percent =\n      value === undefined ? 0 : convertValueToPercentage(value, context.min, context.max);\n    const label = getLabel(index, context.values.length);\n    const orientationSize = size?.[orientation.size];\n    const thumbInBoundsOffset = orientationSize\n      ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction)\n      : 0;\n\n    React.useEffect(() => {\n      if (thumb) {\n        context.thumbs.add(thumb);\n        return () => {\n          context.thumbs.delete(thumb);\n        };\n      }\n    }, [thumb, context.thumbs]);\n\n    return (\n      <span\n        style={{\n          transform: 'var(--radix-slider-thumb-transform)',\n          position: 'absolute',\n          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`,\n        }}\n      >\n        <Collection.ItemSlot scope={props.__scopeSlider}>\n          <Primitive.span\n            role=\"slider\"\n            aria-label={props['aria-label'] || label}\n            aria-valuemin={context.min}\n            aria-valuenow={value}\n            aria-valuemax={context.max}\n            aria-orientation={context.orientation}\n            data-orientation={context.orientation}\n            data-disabled={context.disabled ? '' : undefined}\n            tabIndex={context.disabled ? undefined : 0}\n            {...thumbProps}\n            ref={composedRefs}\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            style={value === undefined ? { display: 'none' } : props.style}\n            onFocus={composeEventHandlers(props.onFocus, () => {\n              context.valueIndexToChangeRef.current = index;\n            })}\n          />\n        </Collection.ItemSlot>\n\n        {isFormControl && (\n          <SliderBubbleInput\n            key={index}\n            name={\n              name ??\n              (context.name ? context.name + (context.values.length > 1 ? '[]' : '') : undefined)\n            }\n            form={context.form}\n            value={value}\n          />\n        )}\n      </span>\n    );\n  }\n);\n\nSliderThumb.displayName = THUMB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderBubbleInput\n * -----------------------------------------------------------------------------------------------*/\n\nconst BUBBLE_INPUT_NAME = 'RadioBubbleInput';\n\ntype InputProps = React.ComponentPropsWithoutRef<typeof Primitive.input>;\ninterface SliderBubbleInputProps extends InputProps {}\n\nconst SliderBubbleInput = React.forwardRef<HTMLInputElement, SliderBubbleInputProps>(\n  ({ __scopeSlider, value, ...props }: ScopedProps<SliderBubbleInputProps>, forwardedRef) => {\n    const ref = React.useRef<HTMLInputElement>(null);\n    const composedRefs = useComposedRefs(ref, forwardedRef);\n    const prevValue = usePrevious(value);\n\n    // Bubble value change to parents (e.g form change event)\n    React.useEffect(() => {\n      const input = ref.current;\n      if (!input) return;\n\n      const inputProto = window.HTMLInputElement.prototype;\n      const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'value') as PropertyDescriptor;\n      const setValue = descriptor.set;\n      if (prevValue !== value && setValue) {\n        const event = new Event('input', { bubbles: true });\n        setValue.call(input, value);\n        input.dispatchEvent(event);\n      }\n    }, [prevValue, value]);\n\n    /**\n     * We purposefully do not use `type=\"hidden\"` here otherwise forms that\n     * wrap it will not be able to access its value via the FormData API.\n     *\n     * We purposefully do not add the `value` attribute here to allow the value\n     * to be set programmatically and bubble to any parent form `onChange` event.\n     * Adding the `value` will cause React to consider the programmatic\n     * dispatch a duplicate and it will get swallowed.\n     */\n    return (\n      <Primitive.input\n        style={{ display: 'none' }}\n        {...props}\n        ref={composedRefs}\n        defaultValue={value}\n      />\n    );\n  }\n);\n\nSliderBubbleInput.displayName = BUBBLE_INPUT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\n\nfunction convertValueToPercentage(value: number, min: number, max: number) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  const percentage = percentPerStep * (value - min);\n  return clamp(percentage, [0, 100]);\n}\n\n/**\n * Returns a label for each thumb when there are two or more thumbs\n */\nfunction getLabel(index: number, totalValues: number) {\n  if (totalValues > 2) {\n    return `Value ${index + 1} of ${totalValues}`;\n  } else if (totalValues === 2) {\n    return ['Minimum', 'Maximum'][index];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Given a `values` array and a `nextValue`, determine which value in\n * the array is closest to `nextValue` and return its index.\n *\n * @example\n * // returns 1\n * getClosestValueIndex([10, 30], 25);\n */\nfunction getClosestValueIndex(values: number[], nextValue: number) {\n  if (values.length === 1) return 0;\n  const distances = values.map((value) => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\n\n/**\n * Offsets the thumb centre point while sliding to ensure it remains\n * within the bounds of the slider when reaching the edges\n */\nfunction getThumbInBoundsOffset(width: number, left: number, direction: number) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\n\n/**\n * Gets an array of steps between each value.\n *\n * @example\n * // returns [1, 9]\n * getStepsBetweenValues([10, 11, 20]);\n */\nfunction getStepsBetweenValues(values: number[]) {\n  return values.slice(0, -1).map((value, index) => values[index + 1]! - value);\n}\n\n/**\n * Verifies the minimum steps between all values is greater than or equal\n * to the expected minimum steps.\n *\n * @example\n * // returns false\n * hasMinStepsBetweenValues([1,2,3], 2);\n *\n * @example\n * // returns true\n * hasMinStepsBetweenValues([1,2,3], 1);\n */\nfunction hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n  return true;\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction getDecimalCount(value: number) {\n  return (String(value).split('.')[1] || '').length;\n}\n\nfunction roundValue(value: number, decimalCount: number) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\n\nconst Root = Slider;\nconst Track = SliderTrack;\nconst Range = SliderRange;\nconst Thumb = SliderThumb;\n\nexport {\n  createSliderScope,\n  //\n  Slider,\n  SliderTrack,\n  SliderRange,\n  SliderThumb,\n  //\n  Root,\n  Track,\n  Range,\n  Thumb,\n};\nexport type { SliderProps, SliderTrackProps, SliderRangeProps, SliderThumbProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}