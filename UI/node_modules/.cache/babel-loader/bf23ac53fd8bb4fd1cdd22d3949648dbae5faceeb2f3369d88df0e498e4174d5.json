{"ast":null,"code":"import _objectSpread from \"/Users/saisaran/Desktop/BirdTag/UI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { StorageAction } from '@aws-amplify/core/internals/utils';\nimport '@smithy/md5-js';\nimport '@aws-amplify/core/internals/aws-client-utils';\nimport '../../utils/client/runtime/s3TransferHandler/fetch.mjs';\nimport 'fast-xml-parser';\nimport '../../utils/client/runtime/s3TransferHandler/xhr.mjs';\nimport 'buffer';\nimport { resolveS3ConfigAndInput } from '../../utils/resolveS3ConfigAndInput.mjs';\nimport { assertValidationError } from '../../../../errors/utils/assertValidationError.mjs';\nimport { StorageValidationErrorCode } from '../../../../errors/types/validation.mjs';\nimport { logger } from '../../../../utils/logger.mjs';\nimport { validateBucketOwnerID } from '../../utils/validateBucketOwnerID.mjs';\nimport { validateStorageOperationInput } from '../../utils/validateStorageOperationInput.mjs';\nimport { isInputWithPath } from '../../utils/isInputWithPath.mjs';\nimport '../../utils/client/s3data/base.mjs';\nimport '../../utils/client/s3data/getObject.mjs';\nimport '../../utils/client/s3data/listObjectsV2.mjs';\nimport '../../utils/client/s3data/putObject.mjs';\nimport '../../utils/client/s3data/createMultipartUpload.mjs';\nimport '../../utils/client/s3data/uploadPart.mjs';\nimport '../../utils/client/s3data/completeMultipartUpload.mjs';\nimport '../../utils/client/s3data/listParts.mjs';\nimport '../../utils/client/s3data/abortMultipartUpload.mjs';\nimport { copyObject } from '../../utils/client/s3data/copyObject.mjs';\nimport '../../utils/client/s3data/headObject.mjs';\nimport '../../utils/client/s3data/deleteObject.mjs';\nimport { getStorageUserAgentValue } from '../../utils/userAgent.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst isCopyInputWithPath = input => isInputWithPath(input.source);\nconst storageBucketAssertion = (sourceBucket, destBucket) => {\n  /**  For multi-bucket, both source and destination bucket needs to be passed in\n   *   or both can be undefined and we fallback to singleton's default value\n   */\n  assertValidationError(\n  // Both src & dest bucket option is present is acceptable\n  sourceBucket !== undefined && destBucket !== undefined ||\n  // or both are undefined is also acceptable\n  !destBucket && !sourceBucket, StorageValidationErrorCode.InvalidCopyOperationStorageBucket);\n};\nconst copy = async (amplify, input) => {\n  return isCopyInputWithPath(input) ? copyWithPath(amplify, input) : copyWithKey(amplify, input);\n};\nconst copyWithPath = async (amplify, input) => {\n  var _input$options, _input$options2, _input$options3, _input$source, _input$destination;\n  const {\n    source,\n    destination\n  } = input;\n  storageBucketAssertion(source.bucket, destination.bucket);\n  const {\n    bucket: sourceBucket\n  } = await resolveS3ConfigAndInput(amplify, {\n    path: input.source.path,\n    options: _objectSpread({\n      locationCredentialsProvider: (_input$options = input.options) === null || _input$options === void 0 ? void 0 : _input$options.locationCredentialsProvider\n    }, input.source)\n  });\n  // The bucket, region, credentials of s3 client are resolved from destination.\n  // Whereas the source bucket and path are a input parameter of S3 copy operation.\n  const {\n    s3Config,\n    bucket: destBucket,\n    identityId\n  } = await resolveS3ConfigAndInput(amplify, {\n    path: input.destination.path,\n    options: _objectSpread({\n      locationCredentialsProvider: (_input$options2 = input.options) === null || _input$options2 === void 0 ? void 0 : _input$options2.locationCredentialsProvider,\n      customEndpoint: (_input$options3 = input.options) === null || _input$options3 === void 0 ? void 0 : _input$options3.customEndpoint\n    }, input.destination)\n  }); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n  assertValidationError(!!source.path, StorageValidationErrorCode.NoSourcePath);\n  assertValidationError(!!destination.path, StorageValidationErrorCode.NoDestinationPath);\n  const {\n    objectKey: sourcePath\n  } = validateStorageOperationInput(source, identityId);\n  const {\n    objectKey: destinationPath\n  } = validateStorageOperationInput(destination, identityId);\n  validateBucketOwnerID(source.expectedBucketOwner);\n  validateBucketOwnerID(destination.expectedBucketOwner);\n  const finalCopySource = \"\".concat(sourceBucket, \"/\").concat(sourcePath);\n  const finalCopyDestination = destinationPath;\n  logger.debug(\"copying \\\"\".concat(finalCopySource, \"\\\" to \\\"\").concat(finalCopyDestination, \"\\\".\"));\n  await serviceCopy({\n    source: finalCopySource,\n    destination: finalCopyDestination,\n    bucket: destBucket,\n    s3Config,\n    notModifiedSince: input.source.notModifiedSince,\n    eTag: input.source.eTag,\n    expectedSourceBucketOwner: (_input$source = input.source) === null || _input$source === void 0 ? void 0 : _input$source.expectedBucketOwner,\n    expectedBucketOwner: (_input$destination = input.destination) === null || _input$destination === void 0 ? void 0 : _input$destination.expectedBucketOwner\n  });\n  return {\n    path: finalCopyDestination\n  };\n};\n/** @deprecated Use {@link copyWithPath} instead. */\nconst copyWithKey = async (amplify, input) => {\n  var _input$options4, _input$options5, _input$source2, _input$destination2;\n  const {\n    source,\n    destination\n  } = input;\n  storageBucketAssertion(source.bucket, destination.bucket);\n  assertValidationError(!!source.key, StorageValidationErrorCode.NoSourceKey);\n  assertValidationError(!!destination.key, StorageValidationErrorCode.NoDestinationKey);\n  validateBucketOwnerID(source.expectedBucketOwner);\n  validateBucketOwnerID(destination.expectedBucketOwner);\n  const {\n    bucket: sourceBucket,\n    keyPrefix: sourceKeyPrefix\n  } = await resolveS3ConfigAndInput(amplify, _objectSpread(_objectSpread({}, input), {}, {\n    options: _objectSpread({\n      // @ts-expect-error: 'options' does not exist on type 'CopyInput'. In case of JS users set the location\n      // credentials provider option, resolveS3ConfigAndInput will throw validation error.\n      locationCredentialsProvider: (_input$options4 = input.options) === null || _input$options4 === void 0 ? void 0 : _input$options4.locationCredentialsProvider\n    }, input.source)\n  }));\n  // The bucket, region, credentials of s3 client are resolved from destination.\n  // Whereas the source bucket and path are a input parameter of S3 copy operation.\n  const {\n    s3Config,\n    bucket: destBucket,\n    keyPrefix: destinationKeyPrefix\n  } = await resolveS3ConfigAndInput(amplify, _objectSpread(_objectSpread({}, input), {}, {\n    options: _objectSpread({\n      // @ts-expect-error: 'options' does not exist on type 'CopyInput'. In case of JS users set the location\n      // credentials provider option, resolveS3ConfigAndInput will throw validation error.\n      locationCredentialsProvider: (_input$options5 = input.options) === null || _input$options5 === void 0 ? void 0 : _input$options5.locationCredentialsProvider\n    }, input.destination)\n  })); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n  // TODO(ashwinkumar6) V6-logger: warn `You may copy files from another user if the source level is \"protected\", currently it's ${srcLevel}`\n  const finalCopySource = \"\".concat(sourceBucket, \"/\").concat(sourceKeyPrefix).concat(source.key);\n  const finalCopyDestination = \"\".concat(destinationKeyPrefix).concat(destination.key);\n  logger.debug(\"copying \\\"\".concat(finalCopySource, \"\\\" to \\\"\").concat(finalCopyDestination, \"\\\".\"));\n  await serviceCopy({\n    source: finalCopySource,\n    destination: finalCopyDestination,\n    bucket: destBucket,\n    s3Config,\n    notModifiedSince: input.source.notModifiedSince,\n    eTag: input.source.eTag,\n    expectedSourceBucketOwner: (_input$source2 = input.source) === null || _input$source2 === void 0 ? void 0 : _input$source2.expectedBucketOwner,\n    expectedBucketOwner: (_input$destination2 = input.destination) === null || _input$destination2 === void 0 ? void 0 : _input$destination2.expectedBucketOwner\n  });\n  return {\n    key: destination.key\n  };\n};\nconst serviceCopy = async _ref => {\n  let {\n    source,\n    destination,\n    bucket,\n    s3Config,\n    notModifiedSince,\n    eTag,\n    expectedSourceBucketOwner,\n    expectedBucketOwner\n  } = _ref;\n  await copyObject(_objectSpread(_objectSpread({}, s3Config), {}, {\n    userAgentValue: getStorageUserAgentValue(StorageAction.Copy)\n  }), {\n    Bucket: bucket,\n    CopySource: source,\n    Key: destination,\n    MetadataDirective: 'COPY',\n    // Copies over metadata like contentType as well\n    CopySourceIfMatch: eTag,\n    CopySourceIfUnmodifiedSince: notModifiedSince,\n    ExpectedSourceBucketOwner: expectedSourceBucketOwner,\n    ExpectedBucketOwner: expectedBucketOwner\n  });\n};\nexport { copy, copyWithKey };","map":{"version":3,"names":["isCopyInputWithPath","input","isInputWithPath","source","storageBucketAssertion","sourceBucket","destBucket","assertValidationError","undefined","StorageValidationErrorCode","InvalidCopyOperationStorageBucket","copy","amplify","copyWithPath","copyWithKey","_input$options","_input$options2","_input$options3","_input$source","_input$destination","destination","bucket","resolveS3ConfigAndInput","path","options","_objectSpread","locationCredentialsProvider","s3Config","identityId","customEndpoint","NoSourcePath","NoDestinationPath","objectKey","sourcePath","validateStorageOperationInput","destinationPath","validateBucketOwnerID","expectedBucketOwner","finalCopySource","concat","finalCopyDestination","logger","debug","serviceCopy","notModifiedSince","eTag","expectedSourceBucketOwner","_input$options4","_input$options5","_input$source2","_input$destination2","key","NoSourceKey","NoDestinationKey","keyPrefix","sourceKeyPrefix","destinationKeyPrefix","_ref","copyObject","userAgentValue","getStorageUserAgentValue","StorageAction","Copy","Bucket","CopySource","Key","MetadataDirective","CopySourceIfMatch","CopySourceIfUnmodifiedSince","ExpectedSourceBucketOwner","ExpectedBucketOwner"],"sources":["/Users/saisaran/Desktop/BirdTag/UI/node_modules/@aws-amplify/storage/src/providers/s3/apis/internal/copy.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { StorageAction } from '@aws-amplify/core/internals/utils';\nimport { isInputWithPath, resolveS3ConfigAndInput, validateBucketOwnerID, validateStorageOperationInput, } from '../../utils';\nimport { StorageValidationErrorCode } from '../../../../errors/types/validation';\nimport { assertValidationError } from '../../../../errors/utils/assertValidationError';\nimport { copyObject } from '../../utils/client/s3data';\nimport { getStorageUserAgentValue } from '../../utils/userAgent';\nimport { logger } from '../../../../utils';\nconst isCopyInputWithPath = (input) => isInputWithPath(input.source);\nconst storageBucketAssertion = (sourceBucket, destBucket) => {\n    /**  For multi-bucket, both source and destination bucket needs to be passed in\n     *   or both can be undefined and we fallback to singleton's default value\n     */\n    assertValidationError(\n    // Both src & dest bucket option is present is acceptable\n    (sourceBucket !== undefined && destBucket !== undefined) ||\n        // or both are undefined is also acceptable\n        (!destBucket && !sourceBucket), StorageValidationErrorCode.InvalidCopyOperationStorageBucket);\n};\nexport const copy = async (amplify, input) => {\n    return isCopyInputWithPath(input)\n        ? copyWithPath(amplify, input)\n        : copyWithKey(amplify, input);\n};\nconst copyWithPath = async (amplify, input) => {\n    const { source, destination } = input;\n    storageBucketAssertion(source.bucket, destination.bucket);\n    const { bucket: sourceBucket } = await resolveS3ConfigAndInput(amplify, {\n        path: input.source.path,\n        options: {\n            locationCredentialsProvider: input.options?.locationCredentialsProvider,\n            ...input.source,\n        },\n    });\n    // The bucket, region, credentials of s3 client are resolved from destination.\n    // Whereas the source bucket and path are a input parameter of S3 copy operation.\n    const { s3Config, bucket: destBucket, identityId, } = await resolveS3ConfigAndInput(amplify, {\n        path: input.destination.path,\n        options: {\n            locationCredentialsProvider: input.options?.locationCredentialsProvider,\n            customEndpoint: input.options?.customEndpoint,\n            ...input.destination,\n        },\n    }); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n    assertValidationError(!!source.path, StorageValidationErrorCode.NoSourcePath);\n    assertValidationError(!!destination.path, StorageValidationErrorCode.NoDestinationPath);\n    const { objectKey: sourcePath } = validateStorageOperationInput(source, identityId);\n    const { objectKey: destinationPath } = validateStorageOperationInput(destination, identityId);\n    validateBucketOwnerID(source.expectedBucketOwner);\n    validateBucketOwnerID(destination.expectedBucketOwner);\n    const finalCopySource = `${sourceBucket}/${sourcePath}`;\n    const finalCopyDestination = destinationPath;\n    logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n    await serviceCopy({\n        source: finalCopySource,\n        destination: finalCopyDestination,\n        bucket: destBucket,\n        s3Config,\n        notModifiedSince: input.source.notModifiedSince,\n        eTag: input.source.eTag,\n        expectedSourceBucketOwner: input.source?.expectedBucketOwner,\n        expectedBucketOwner: input.destination?.expectedBucketOwner,\n    });\n    return { path: finalCopyDestination };\n};\n/** @deprecated Use {@link copyWithPath} instead. */\nexport const copyWithKey = async (amplify, input) => {\n    const { source, destination } = input;\n    storageBucketAssertion(source.bucket, destination.bucket);\n    assertValidationError(!!source.key, StorageValidationErrorCode.NoSourceKey);\n    assertValidationError(!!destination.key, StorageValidationErrorCode.NoDestinationKey);\n    validateBucketOwnerID(source.expectedBucketOwner);\n    validateBucketOwnerID(destination.expectedBucketOwner);\n    const { bucket: sourceBucket, keyPrefix: sourceKeyPrefix } = await resolveS3ConfigAndInput(amplify, {\n        ...input,\n        options: {\n            // @ts-expect-error: 'options' does not exist on type 'CopyInput'. In case of JS users set the location\n            // credentials provider option, resolveS3ConfigAndInput will throw validation error.\n            locationCredentialsProvider: input.options?.locationCredentialsProvider,\n            ...input.source,\n        },\n    });\n    // The bucket, region, credentials of s3 client are resolved from destination.\n    // Whereas the source bucket and path are a input parameter of S3 copy operation.\n    const { s3Config, bucket: destBucket, keyPrefix: destinationKeyPrefix, } = await resolveS3ConfigAndInput(amplify, {\n        ...input,\n        options: {\n            // @ts-expect-error: 'options' does not exist on type 'CopyInput'. In case of JS users set the location\n            // credentials provider option, resolveS3ConfigAndInput will throw validation error.\n            locationCredentialsProvider: input.options?.locationCredentialsProvider,\n            ...input.destination,\n        },\n    }); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n    // TODO(ashwinkumar6) V6-logger: warn `You may copy files from another user if the source level is \"protected\", currently it's ${srcLevel}`\n    const finalCopySource = `${sourceBucket}/${sourceKeyPrefix}${source.key}`;\n    const finalCopyDestination = `${destinationKeyPrefix}${destination.key}`;\n    logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n    await serviceCopy({\n        source: finalCopySource,\n        destination: finalCopyDestination,\n        bucket: destBucket,\n        s3Config,\n        notModifiedSince: input.source.notModifiedSince,\n        eTag: input.source.eTag,\n        expectedSourceBucketOwner: input.source?.expectedBucketOwner,\n        expectedBucketOwner: input.destination?.expectedBucketOwner,\n    });\n    return {\n        key: destination.key,\n    };\n};\nconst serviceCopy = async ({ source, destination, bucket, s3Config, notModifiedSince, eTag, expectedSourceBucketOwner, expectedBucketOwner, }) => {\n    await copyObject({\n        ...s3Config,\n        userAgentValue: getStorageUserAgentValue(StorageAction.Copy),\n    }, {\n        Bucket: bucket,\n        CopySource: source,\n        Key: destination,\n        MetadataDirective: 'COPY', // Copies over metadata like contentType as well\n        CopySourceIfMatch: eTag,\n        CopySourceIfUnmodifiedSince: notModifiedSince,\n        ExpectedSourceBucketOwner: expectedSourceBucketOwner,\n        ExpectedBucketOwner: expectedBucketOwner,\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}