{"ast":null,"code":"import _objectSpread from \"/Users/saisaran/Desktop/BirdTag/UI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { defaultTheme } from '../defaultTheme.mjs';\nimport { deepExtend, setupTokens, flattenProperties, setupToken } from './utils.mjs';\nimport { createComponentCSS } from './createComponentCSS.mjs';\nimport '@aws-amplify/core/internals/utils';\nimport '../../utils/setUserAgent/constants.mjs';\nimport { isString } from '../../utils/utils.mjs';\nimport { createColorPalette } from './createColorPalette.mjs';\nimport { createAnimationCSS } from './createAnimationCSS.mjs';\n\n/**\n * This will be used like `const myTheme = createTheme({})`\n * `myTheme` can then be passed to a Provider or the generated CSS\n * can be passed to a stylesheet at build-time or run-time.\n * const myTheme = createTheme({})\n * const myOtherTheme = createTheme({}, myTheme);\n */\nfunction createTheme(theme) {\n  let DefaultTheme = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultTheme;\n  // merge theme and DefaultTheme to get a complete theme\n  // deepExtend is an internal Style Dictionary method\n  // that performs a deep merge on n objects. We could change\n  // this to another 3p deep merge solution too.\n  const mergedTheme = deepExtend([{}, DefaultTheme, _objectSpread(_objectSpread({}, theme), {}, {\n    components: {}\n  })]);\n  const {\n    primaryColor,\n    secondaryColor\n  } = mergedTheme;\n  // apply primaryColor and secondaryColor if present\n  if (isString(primaryColor)) {\n    mergedTheme.tokens.colors.primary = createColorPalette({\n      keys: Object.keys(mergedTheme.tokens.colors[primaryColor]),\n      value: primaryColor\n    });\n  }\n  if (isString(secondaryColor)) {\n    mergedTheme.tokens.colors.secondary = createColorPalette({\n      keys: Object.keys(mergedTheme.tokens.colors[secondaryColor]),\n      value: secondaryColor\n    });\n  }\n  // Setting up the tokens. This is similar to what Style Dictionary\n  // does. At the end of this, each token should have:\n  // - CSS variable name of itself\n  // - its value (reference to another CSS variable or raw value)\n  const tokens = setupTokens({\n    tokens: mergedTheme.tokens,\n    setupToken\n  }); // Setting the type here because setupTokens is recursive\n  const {\n    breakpoints,\n    name\n  } = mergedTheme;\n  // flattenProperties is another internal Style Dictionary function\n  // that creates an array of all tokens.\n  let cssText = \"[data-amplify-theme=\\\"\".concat(name, \"\\\"] {\\n\") + flattenProperties(tokens).map(token => \"\".concat(token.name, \": \").concat(token.value, \";\")).join('\\n') + \"\\n}\\n\";\n  if (theme !== null && theme !== void 0 && theme.components) {\n    cssText += createComponentCSS({\n      theme: _objectSpread(_objectSpread({}, mergedTheme), {}, {\n        tokens\n      }),\n      components: theme.components\n    });\n  }\n  let overrides = [];\n  if (mergedTheme.animations) {\n    cssText += createAnimationCSS({\n      animations: mergedTheme.animations,\n      tokens\n    });\n  }\n  /**\n   * For each override, we setup the tokens and then generate the CSS.\n   * This allows us to have one single CSS string for all possible overrides\n   * and avoid re-renders in React, but also support other frameworks as well.\n   */\n  if (mergedTheme.overrides) {\n    overrides = mergedTheme.overrides.map(override => {\n      const overrideTokens = setupTokens({\n        tokens: override.tokens,\n        setupToken\n      });\n      const customProperties = flattenProperties(overrideTokens).map(token => \"\".concat(token.name, \": \").concat(token.value, \";\")).join('\\n');\n      // Overrides can have a selector, media query, breakpoint, or color mode\n      // for creating the selector\n      if ('selector' in override) {\n        cssText += \"\\n\".concat(override.selector, \" {\\n\").concat(customProperties, \"\\n}\\n\");\n      }\n      if ('mediaQuery' in override) {\n        cssText += \"\\n@media (\".concat(override.mediaQuery, \") {\\n  [data-amplify-theme=\\\"\").concat(name, \"\\\"] {\\n    \").concat(customProperties, \"\\n  }\\n}\\n\");\n      }\n      if ('breakpoint' in override) {\n        const breakpoint = mergedTheme.breakpoints.values[override.breakpoint];\n        cssText += \"\\n@media (min-width: \".concat(breakpoint, \"px) {\\n  [data-amplify-theme=\\\"\").concat(name, \"\\\"] {\\n    \").concat(customProperties, \"\\n  }\\n}\\n\");\n      }\n      if ('colorMode' in override) {\n        cssText += \"\\n@media (prefers-color-scheme: \".concat(override.colorMode, \") {\\n          [data-amplify-theme=\\\"\").concat(name, \"\\\"][data-amplify-color-mode=\\\"system\\\"] {\\n            \").concat(customProperties, \"\\n            color-scheme: \").concat(override.colorMode, \";\\n          }\\n        }\\n\");\n        cssText += \"\\n[data-amplify-theme=\\\"\".concat(name, \"\\\"][data-amplify-color-mode=\\\"\").concat(override.colorMode, \"\\\"] {\\n          \").concat(customProperties, \"\\n          color-scheme: \").concat(override.colorMode, \";\\n        }\\n\");\n      }\n      return _objectSpread(_objectSpread({}, override), {}, {\n        tokens: overrideTokens\n      });\n    });\n  }\n  return {\n    tokens,\n    breakpoints,\n    name,\n    cssText,\n    containerProps: function () {\n      let {\n        colorMode\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        'data-amplify-theme': name,\n        'data-amplify-color-mode': colorMode\n      };\n    },\n    // keep overrides separate from base theme\n    // this allows web platforms to use plain CSS scoped to a\n    // selector and only override the CSS vars needed. This\n    // means we could generate CSS at build-time in a postcss\n    // plugin, or do it at runtime and inject the CSS into a\n    // style tag.\n    // This also allows RN to dynamically switch themes in a\n    // provider.\n    overrides\n  };\n}\nexport { createTheme };","map":{"version":3,"names":["defaultTheme","deepExtend","setupTokens","flattenProperties","setupToken","createComponentCSS","isString","createColorPalette","createAnimationCSS","createTheme","theme","DefaultTheme","arguments","length","undefined","mergedTheme","_objectSpread","components","primaryColor","secondaryColor","tokens","colors","primary","keys","Object","value","secondary","breakpoints","name","cssText","concat","map","token","join","overrides","animations","override","overrideTokens","customProperties","selector","mediaQuery","breakpoint","values","colorMode","containerProps"],"sources":["/Users/saisaran/Desktop/BirdTag/UI/node_modules/@aws-amplify/ui/dist/esm/theme/createTheme/createTheme.mjs"],"sourcesContent":["import { defaultTheme } from '../defaultTheme.mjs';\nimport { deepExtend, setupTokens, flattenProperties, setupToken } from './utils.mjs';\nimport { createComponentCSS } from './createComponentCSS.mjs';\nimport '@aws-amplify/core/internals/utils';\nimport '../../utils/setUserAgent/constants.mjs';\nimport { isString } from '../../utils/utils.mjs';\nimport { createColorPalette } from './createColorPalette.mjs';\nimport { createAnimationCSS } from './createAnimationCSS.mjs';\n\n/**\n * This will be used like `const myTheme = createTheme({})`\n * `myTheme` can then be passed to a Provider or the generated CSS\n * can be passed to a stylesheet at build-time or run-time.\n * const myTheme = createTheme({})\n * const myOtherTheme = createTheme({}, myTheme);\n */\nfunction createTheme(theme, DefaultTheme = defaultTheme) {\n    // merge theme and DefaultTheme to get a complete theme\n    // deepExtend is an internal Style Dictionary method\n    // that performs a deep merge on n objects. We could change\n    // this to another 3p deep merge solution too.\n    const mergedTheme = deepExtend([\n        {},\n        DefaultTheme,\n        {\n            ...theme,\n            components: {},\n        },\n    ]);\n    const { primaryColor, secondaryColor } = mergedTheme;\n    // apply primaryColor and secondaryColor if present\n    if (isString(primaryColor)) {\n        mergedTheme.tokens.colors.primary = createColorPalette({\n            keys: Object.keys(mergedTheme.tokens.colors[primaryColor]),\n            value: primaryColor,\n        });\n    }\n    if (isString(secondaryColor)) {\n        mergedTheme.tokens.colors.secondary = createColorPalette({\n            keys: Object.keys(mergedTheme.tokens.colors[secondaryColor]),\n            value: secondaryColor,\n        });\n    }\n    // Setting up the tokens. This is similar to what Style Dictionary\n    // does. At the end of this, each token should have:\n    // - CSS variable name of itself\n    // - its value (reference to another CSS variable or raw value)\n    const tokens = setupTokens({\n        tokens: mergedTheme.tokens,\n        setupToken,\n    }); // Setting the type here because setupTokens is recursive\n    const { breakpoints, name } = mergedTheme;\n    // flattenProperties is another internal Style Dictionary function\n    // that creates an array of all tokens.\n    let cssText = `[data-amplify-theme=\"${name}\"] {\\n` +\n        flattenProperties(tokens)\n            .map((token) => `${token.name}: ${token.value};`)\n            .join('\\n') +\n        `\\n}\\n`;\n    if (theme?.components) {\n        cssText += createComponentCSS({\n            theme: {\n                ...mergedTheme,\n                tokens,\n            },\n            components: theme.components,\n        });\n    }\n    let overrides = [];\n    if (mergedTheme.animations) {\n        cssText += createAnimationCSS({\n            animations: mergedTheme.animations,\n            tokens,\n        });\n    }\n    /**\n     * For each override, we setup the tokens and then generate the CSS.\n     * This allows us to have one single CSS string for all possible overrides\n     * and avoid re-renders in React, but also support other frameworks as well.\n     */\n    if (mergedTheme.overrides) {\n        overrides = mergedTheme.overrides.map((override) => {\n            const overrideTokens = setupTokens({\n                tokens: override.tokens,\n                setupToken,\n            });\n            const customProperties = flattenProperties(overrideTokens)\n                .map((token) => `${token.name}: ${token.value};`)\n                .join('\\n');\n            // Overrides can have a selector, media query, breakpoint, or color mode\n            // for creating the selector\n            if ('selector' in override) {\n                cssText += `\\n${override.selector} {\\n${customProperties}\\n}\\n`;\n            }\n            if ('mediaQuery' in override) {\n                cssText += `\\n@media (${override.mediaQuery}) {\n  [data-amplify-theme=\"${name}\"] {\n    ${customProperties}\n  }\n}\\n`;\n            }\n            if ('breakpoint' in override) {\n                const breakpoint = mergedTheme.breakpoints.values[override.breakpoint];\n                cssText += `\\n@media (min-width: ${breakpoint}px) {\n  [data-amplify-theme=\"${name}\"] {\n    ${customProperties}\n  }\n}\\n`;\n            }\n            if ('colorMode' in override) {\n                cssText += `\\n@media (prefers-color-scheme: ${override.colorMode}) {\n          [data-amplify-theme=\"${name}\"][data-amplify-color-mode=\"system\"] {\n            ${customProperties}\n            color-scheme: ${override.colorMode};\n          }\n        }\\n`;\n                cssText += `\\n[data-amplify-theme=\"${name}\"][data-amplify-color-mode=\"${override.colorMode}\"] {\n          ${customProperties}\n          color-scheme: ${override.colorMode};\n        }\\n`;\n            }\n            return {\n                ...override,\n                tokens: overrideTokens,\n            };\n        });\n    }\n    return {\n        tokens,\n        breakpoints,\n        name,\n        cssText,\n        containerProps: ({ colorMode } = {}) => {\n            return {\n                'data-amplify-theme': name,\n                'data-amplify-color-mode': colorMode,\n            };\n        },\n        // keep overrides separate from base theme\n        // this allows web platforms to use plain CSS scoped to a\n        // selector and only override the CSS vars needed. This\n        // means we could generate CSS at build-time in a postcss\n        // plugin, or do it at runtime and inject the CSS into a\n        // style tag.\n        // This also allows RN to dynamically switch themes in a\n        // provider.\n        overrides,\n    };\n}\n\nexport { createTheme };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}